

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Core Programming Guide &mdash; Level Zero Specification  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Tools Programming Guide" href="../tools/PROG.html" />
    <link rel="prev" title="Introduction" href="INTRO.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Level Zero Specification
          

          
          </a>

          
            
            
              <div class="version">
                0.95.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="INTRO.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Core Programming Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#drivers-and-devices">Drivers and Devices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#drivers">Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device">Device</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initialization-and-discovery">Initialization and Discovery</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#memory-and-images">Memory and Images</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#memory">Memory</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#types">Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cache-hints-prefetch-and-memory-advice">Cache Hints, Prefetch, and Memory Advice</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#images">Images</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-cache-settings">Device Cache Settings</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#command-queues-and-command-lists">Command Queues and Command Lists</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#command-queues">Command Queues</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creation">Creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#execution">Execution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#destruction">Destruction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#command-lists">Command Lists</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creation-1">Creation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#appending">Appending</a></li>
<li class="toctree-l4"><a class="reference internal" href="#submission">Submission</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recycling">Recycling</a></li>
<li class="toctree-l4"><a class="reference internal" href="#low-latency-immediate-command-lists">Low-Latency Immediate Command Lists</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#synchronization-primitives">Synchronization Primitives</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#fences">Fences</a></li>
<li class="toctree-l3"><a class="reference internal" href="#events">Events</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kernel-timestamp-events">Kernel Timestamp Events</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#barriers">Barriers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#execution-barriers">Execution Barriers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-barriers">Memory Barriers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#range-based-memory-barriers">Range-based Memory Barriers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#modules-and-kernels">Modules and Kernels</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modules">Modules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-build-options">Module Build Options</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-specialization-constants">Module Specialization Constants</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-build-log">Module Build Log</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-caching-with-native-binaries">Module Caching with Native Binaries</a></li>
<li class="toctree-l4"><a class="reference internal" href="#built-in-kernels">Built-in Kernels</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kernels">Kernels</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kernel-attributes-and-properties">Kernel Attributes and Properties</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#execution-1">Execution</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kernel-group-size">Kernel Group Size</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-arguments">Kernel Arguments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-launch">Kernel Launch</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cooperative-kernels">Cooperative Kernels</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sampler">Sampler</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#advanced">Advanced</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#environment-variables">Environment Variables</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#affinity-mask">Affinity Mask</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#sub-device-support">Sub-Device Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-residency">Device Residency</a></li>
<li class="toctree-l3"><a class="reference internal" href="#opencl-interoperability">OpenCL Interoperability</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cl-mem">cl_mem</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cl-program">cl_program</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cl-command-queue">cl_command_queue</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#inter-process-communication">Inter-Process Communication</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#memory-1">Memory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#events-1">Events</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#peer-to-peer-access-and-queries">Peer-to-Peer Access and Queries</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tools/PROG.html">Tools Programming Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sysman/PROG.html">Sysman Programming Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="SPIRV.html">SPIR-V Programming Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../versions.html">Versions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Level Zero Specification</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    

    

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="core-programming-guide">
<span id="id1"></span><h1>Core Programming Guide<a class="headerlink" href="#core-programming-guide" title="Permalink to this headline">¶</a></h1>
<div class="section" id="drivers-and-devices">
<h2>Drivers and Devices<a class="headerlink" href="#drivers-and-devices" title="Permalink to this headline">¶</a></h2>
<p>The API architecture exposes both physical and logical abstraction of the underlying devices capabilities.
The device, sub-device and memory are exposed at physical level while command queues, events and
synchronization methods are defined as logical entities.
All logical entities will be bound to device level physical capabilities.</p>
<p>Device discovery APIs enumerate the accelerators functional features.
These APIs provide interface to query information like compute unit count within the device or sub device,
available memory and affinity to the compute, user managed cache size and work submission command queues.</p>
<div class="section" id="drivers">
<h3>Drivers<a class="headerlink" href="#drivers" title="Permalink to this headline">¶</a></h3>
<p>A driver object represents a collection of physical devices in the system accessed by the same Level-Zero driver.</p>
<ul class="simple">
<li><p>The application may query the number of Level-Zero drivers installed on the system, and their respective handles, using <a class="reference internal" href="api.html#zedriverget"><span class="std std-ref">zeDriverGet</span></a>.</p></li>
<li><p>More than one driver may be available in the system. For example, one driver may support two GPUs from one vendor, another driver supports a GPU from a different vendor, and finally a different driver may support an FPGA.</p></li>
<li><p>Driver objects are read-only, global constructs. i.e. Multiple calls to <a class="reference internal" href="api.html#zedriverget"><span class="std std-ref">zeDriverGet</span></a> will return identical driver handles.</p></li>
<li><p>A driver handle is primarily used during creation and management of resources that may be used by multiple devices.</p></li>
<li><p>For example, memory is not implicitly shared across all devices supported by a driver. However, it is available to be explicitly shared.</p></li>
</ul>
</div>
<div class="section" id="device">
<h3>Device<a class="headerlink" href="#device" title="Permalink to this headline">¶</a></h3>
<p>A device object represents a physical device in the system that supports Level-Zero.</p>
<ul class="simple">
<li><p>The application may query the number devices supported by a driver, and their respective handles, using <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a>.</p></li>
<li><p>Device objects are read-only, global constructs. i.e. Multiple calls to <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a> will return identical device handles.</p></li>
<li><p>A device handle is primarily used during creation and management of resources that are specific to a device.</p></li>
<li><p>The application is responsible for sharing memory and explicit submission and synchronization across multiple devices.</p></li>
<li><p>Device may expose sub-devices that allow finer-grained control of physical or logical partitions of a device.</p></li>
</ul>
<p>The following diagram illustrates the relationship between the driver, device and other objects described in this document.</p>
<img alt="../_images/core_device.png" src="../_images/core_device.png" />
</div>
<div class="section" id="initialization-and-discovery">
<h3>Initialization and Discovery<a class="headerlink" href="#initialization-and-discovery" title="Permalink to this headline">¶</a></h3>
<p>The Level-Zero API must be initialized by calling <a class="reference internal" href="api.html#zeinit"><span class="std std-ref">zeInit</span></a> before calling any other API function.
This function will load all Level-Zero driver(s) in the system into memory for the current process, for use by all Host threads.
Simultaneous calls to <a class="reference internal" href="api.html#zeinit"><span class="std std-ref">zeInit</span></a> are thread-safe and only one instance of each driver will be loaded.</p>
<p>The following pseudo-code demonstrates a basic initialization and device discovery sequence:</p>
<pre class="literal-block">// Initialize the driver
<a class="reference internal" href="api.html#zeinit"><span class="std std-ref">zeInit</span></a>(<a class="reference internal" href="api.html#ze-init-flag-t"><span class="std std-ref">ZE_INIT_FLAG_NONE</span></a>);

// Discover all the driver instances
uint32_t driverCount = 0;
<a class="reference internal" href="api.html#zedriverget"><span class="std std-ref">zeDriverGet</span></a>(&amp;driverCount, nullptr);

ze_driver_handle_t* allDrivers = allocate(driverCount * sizeof(ze_driver_handle_t));
<a class="reference internal" href="api.html#zedriverget"><span class="std std-ref">zeDriverGet</span></a>(&amp;driverCount, allDrivers);

// Find a driver instance with a GPU device
ze_driver_handle_t hDriver = nullptr;
ze_device_handle_t hDevice = nullptr;
for(i = 0; i &lt; driverCount; ++i) {
    uint32_t deviceCount = 0;
    <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a>(allDrivers[i], &amp;deviceCount, nullptr);

    ze_device_handle_t* allDevices = allocate(deviceCount * sizeof(ze_device_handle_t));
    <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a>(allDrivers[i], &amp;deviceCount, allDevices);

    for(d = 0; d &lt; deviceCount; ++d) {
        <a class="reference internal" href="api.html#ze-device-properties-t"><span class="std std-ref">ze_device_properties_t</span></a> device_properties;
        <a class="reference internal" href="api.html#zedevicegetproperties"><span class="std std-ref">zeDeviceGetProperties</span></a>(allDevices[d], &amp;device_properties);

        if(<a class="reference internal" href="api.html#ze-device-type-t"><span class="std std-ref">ZE_DEVICE_TYPE_GPU</span></a> == device_properties.type) {
            hDriver = allDrivers[i];
            hDevice = allDevices[d];
            break;
        }
    }

    free(allDevices);
    if(nullptr != hDriver) {
        break;
    }
}

free(allDrivers);
if(nullptr == hDevice)
    return; // no GPU devices found

...</pre>
</div>
</div>
<div class="section" id="memory-and-images">
<h2>Memory and Images<a class="headerlink" href="#memory-and-images" title="Permalink to this headline">¶</a></h2>
<p>Memory is visible to the upper-level software stack as unified memory
with a single virtual address space covering both the Host and a
specific device.</p>
<p>For GPUs, the API exposes two levels of the device memory hierarchy:</p>
<ol class="arabic">
<li><p>Local Device Memory: can be managed at the device and/or sub device level.</p></li>
<li><p>Device Cache(s):</p>
<blockquote>
<div><ul class="simple">
<li><p>Last Level Cache (L3) can be controlled through memory allocation APIs.</p></li>
<li><p>Low Level Cache (L1) can be controlled through program language intrinsics.</p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p>The API allows allocation of buffers and images at device and sub device
granularity with full cacheablity hints.</p>
<ul class="simple">
<li><p>Buffers are transparent memory accessed through virtual address pointers</p></li>
<li><p>Images are opaque objects accessed through handles</p></li>
</ul>
<p>The memory APIs provide allocation methods to allocate either device,
host or shared memory. The APIs enable both implicit and explicit
management of the resources by the application or runtimes. The
interface also provides query capabilities for all memory objects.</p>
<p>There are two types of allocations:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#linearmemory"><span class="std std-ref">Memory</span></a> - linear, unformatted allocations for direct access from both the host and device.</p></li>
<li><p><a class="reference internal" href="#images"><span class="std std-ref">Images</span></a> - non-linear, formatted allocations for direct access from the device.</p></li>
</ol>
<div class="section" id="memory">
<span id="linearmemory"></span><h3>Memory<a class="headerlink" href="#memory" title="Permalink to this headline">¶</a></h3>
<p>Linear, unformatted memory allocations are represented as pointers in
the host application. A pointer on the host has the same size as a
pointer on the device.</p>
<div class="section" id="types">
<h4>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h4>
<p>Three types of allocations are supported. The type of allocation
describes the <em>ownership</em> of the allocation:</p>
<p>1. <strong>Host</strong> allocations are
owned by the host and are intended to be allocated out of system memory.
Host allocations are accessible by the host and one or more devices. The
same pointer to a host allocation may be used on the host and all
supported devices; they have <em>address equivalence</em>. Host allocations are
not expected to migrate between system memory and device local memory.
Host allocations trade off wide accessibility and transfer benefits for
potentially higher per-access costs, such as over PCI express.</p>
<p>2. <strong>Device</strong> allocations are owned by a specific device and are intended
to be allocated out of device local memory, if present. Device
allocations generally trade off access limitations for higher
performance. With very few exceptions, device allocations may only be
accessed by the specific device that they are allocated on, or copied to
a host or another device allocation. The same pointer to a device
allocation may be used on any supported device.</p>
<p>3. <strong>Shared</strong>
allocations share ownership and are intended to migrate between the host
and one or more devices. Shared allocations are accessible by at least
the host and an associated device. Shared allocations may be accessed by
other devices in some cases. Shared allocations trade off transfer costs
for per-access benefits. The same pointer to a shared allocation may be
used on the host and all supported devices.</p>
<p>A <strong>Shared System</strong> allocation is a sub-class of a <strong>Shared</strong>
allocation, where the memory is allocated by a <em>system allocator</em> - such
as <code class="docutils literal notranslate"><span class="pre">malloc</span></code> or <code class="docutils literal notranslate"><span class="pre">new</span></code> - rather than by an allocation API. Shared
system allocations have no associated device - they are inherently
cross-device. Like other shared allocations, shared system allocations
are intended to migrate between the host and supported devices, and the
same pointer to a shared system allocation may be used on the host and
all supported devices.</p>
<p>In summary:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 30%" />
<col style="width: 13%" />
<col style="width: 22%" />
<col style="width: 12%" />
<col style="width: 8%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Initial Location</p></th>
<th class="head"><p>Accessible By</p></th>
<th class="head"></th>
<th class="head"><p>Migratable To</p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td rowspan="2"><p><strong>Host</strong></p></td>
<td rowspan="2"><p>Host</p></td>
<td><p>Host</p></td>
<td><p>Yes</p></td>
<td><p>Host</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p>Any Device</p></td>
<td><p>Yes (perhaps over PCIe)</p></td>
<td><p>Device</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td rowspan="3"><p><strong>Device</strong></p></td>
<td rowspan="3"><p>Specific Device</p></td>
<td><p>Host</p></td>
<td><p>No</p></td>
<td><p>Host</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>Specific Device</p></td>
<td><p>Yes</p></td>
<td><p>Device</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td><p>Another Device</p></td>
<td><p>Optional (may require p2p)</p></td>
<td><p>Another Device</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td rowspan="3"><p><strong>Shared</strong></p></td>
<td rowspan="3"><p>Host, Specific Device, or Unspecified</p></td>
<td><p>Host</p></td>
<td><p>Yes</p></td>
<td><p>Host</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p>Specific Device</p></td>
<td><p>Yes</p></td>
<td><p>Device</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Another Device</p></td>
<td><p>Optional (may require p2p)</p></td>
<td><p>Another Device</p></td>
<td><p>Optional</p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p><strong>Shared System</strong></p></td>
<td rowspan="2"><p>Host</p></td>
<td><p>Host</p></td>
<td><p>Yes</p></td>
<td><p>Host</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p>Device</p></td>
<td><p>Yes</p></td>
<td><p>Device</p></td>
<td><p>Yes</p></td>
</tr>
</tbody>
</table>
<p>Devices may support different capabilities for each type of allocation. Supported capabilities are:</p>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#ze-memory-access-caps-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAPS_RW</span></a> - if a device supports access (read or write) to allocations of the specified type.</p></li>
<li><p><a class="reference internal" href="api.html#ze-memory-access-caps-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAPS_ATOMIC</span></a> - if a device support atomic operations on allocations of the specified type. Atomic operations may include relaxed consistency read-modify-write atomics and atomic operations that enforce memory consistency for non-atomic operations.</p></li>
<li><p><a class="reference internal" href="api.html#ze-memory-access-caps-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAPS_CONCURRENT</span></a> - if a device supports concurrent access to allocations of the specified type. Concurrent access may be from another device that supports concurrent access, or from the host. Devices that support concurrent access but do not support concurrent atomic access must write to unique non-overlapping memory locations to avoid data races and hence undefined behavior.</p></li>
<li><p><a class="reference internal" href="api.html#ze-memory-access-caps-t"><span class="std std-ref">ZE_MEMORY_ACCESS_CAPS_CONCURRENT_ATOMIC</span></a> - if a device supports concurrent atomic operations on allocations of the specified type. Concurrent atomic operations may be from another device that supports concurrent atomic access, or from the host. Devices that support concurrent atomic access may use atomic operations to enforce memory consistency with other devices that support concurrent atomic access, or with the host.</p></li>
</ul>
<p>Some devices may <em>oversubscribe</em> some <strong>shared</strong> allocations. When and how such oversubscription occurs, including which allocations are evicted when the working set changes, are considered implementation details.</p>
<p>The required matrix of capabilities are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 10%" />
<col style="width: 14%" />
<col style="width: 18%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Allocation Type</p></th>
<th class="head"><p>RW Access</p></th>
<th class="head"><p>Atomic Access</p></th>
<th class="head"><p>Concurrent Access</p></th>
<th class="head"><p>Concurrent Atomic Access</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Host</strong></p></td>
<td><p>Required</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Device</strong></p></td>
<td><p>Required</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
</tr>
<tr class="row-even"><td><p><strong>Shared</strong></p></td>
<td><p>Required</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Shared</strong> (Cross-Device)</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
</tr>
<tr class="row-even"><td><p><strong>Shared System</strong> (Cross-Device)</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
<td><p>Optional</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cache-hints-prefetch-and-memory-advice">
<h4>Cache Hints, Prefetch, and Memory Advice<a class="headerlink" href="#cache-hints-prefetch-and-memory-advice" title="Permalink to this headline">¶</a></h4>
<p>Cacheability hints may be provided via separate host and device
allocation flags when memory is allocated.</p>
<p><strong>Shared</strong> allocations may be prefetched to a supporting device via the
<a class="reference internal" href="api.html#zecommandlistappendmemoryprefetch"><span class="std std-ref">zeCommandListAppendMemoryPrefetch</span></a> API. Prefetching may allow memory
transfers to be scheduled concurrently with other computations and may
improve performance.</p>
<p>Additionally, an application may provide memory advice for a <strong>shared</strong>
allocation via the <a class="reference internal" href="api.html#zecommandlistappendmemadvise"><span class="std std-ref">zeCommandListAppendMemAdvise</span></a> API, to override
driver heuristics or migration policies. Memory advice may avoid
unnecessary or unprofitable memory transfers and may improve
performance.</p>
<p>Both prefetch and memory advice are asynchronous operations that are
appended into command lists.</p>
</div>
</div>
<div class="section" id="images">
<span id="id2"></span><h3>Images<a class="headerlink" href="#images" title="Permalink to this headline">¶</a></h3>
<p>An image is used to store multi-dimensional and format-defined memory
for optimal device access. An image’s contents can be copied to and from
other images, as well as host-accessible memory allocations. This is the
only method for host access to the contents of an image. This
methodology allows for device-specific encoding of image contents (e.g.,
tile swizzle patterns, lossless compression, etc.) and avoids exposing
these details in the API in a backwards compatible fashion.</p>
<pre class="literal-block">// Specify single component FLOAT32 format
<a class="reference internal" href="api.html#ze-image-format-desc-t"><span class="std std-ref">ze_image_format_desc_t</span></a> formatDesc = {
    <a class="reference internal" href="api.html#ze-image-format-layout-t"><span class="std std-ref">ZE_IMAGE_FORMAT_LAYOUT_32</span></a>, <a class="reference internal" href="api.html#ze-image-format-type-t"><span class="std std-ref">ZE_IMAGE_FORMAT_TYPE_FLOAT</span></a>,
    <a class="reference internal" href="api.html#ze-image-format-swizzle-t"><span class="std std-ref">ZE_IMAGE_FORMAT_SWIZZLE_R</span></a>, <a class="reference internal" href="api.html#ze-image-format-swizzle-t"><span class="std std-ref">:ref:`ZE_IMAGE_FORMAT_SWIZZLE_0</span></a> &lt;ze-image-format-swizzle-t&gt;`, ZE_IMAGE_FORMAT_SWIZZLE_0, <a class="reference internal" href="api.html#ze-image-format-swizzle-t"><span class="std std-ref">ZE_IMAGE_FORMAT_SWIZZLE_1</span></a>
};

<a class="reference internal" href="api.html#ze-image-desc-t"><span class="std std-ref">ze_image_desc_t</span></a> imageDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_IMAGE_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-image-flag-t"><span class="std std-ref">ZE_IMAGE_FLAG_PROGRAM_READ</span></a>,
    <a class="reference internal" href="api.html#ze-image-type-t"><span class="std std-ref">ZE_IMAGE_TYPE_2D</span></a>,
    formatDesc,
    128, 128, 0, 0, 0
};
ze_image_handle_t hImage;
<a class="reference internal" href="api.html#zeimagecreate"><span class="std std-ref">zeImageCreate</span></a>(hDevice, &amp;imageDesc, &amp;hImage);

// upload contents from host pointer
<a class="reference internal" href="api.html#zecommandlistappendimagecopyfrommemory"><span class="std std-ref">zeCommandListAppendImageCopyFromMemory</span></a>(hCommandList, hImage, nullptr, pImageData, nullptr, 0, nullptr);
...</pre>
<p>A format descriptor is a combination of a format layout, type, and a swizzle.
The format layout describes the number of components and their corresponding bit
widths. The type describes the data type for all of these components with some
exceptions that are described below. The swizzles associate how the image
components are mapped into XYZW/RGBA channels of the kernel. It is allowed
to replicate components into the channels.</p>
<p>The following table describes which types are required for each layout.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Format layout</p></th>
<th class="head"><p>UINT</p></th>
<th class="head"><p>SINT</p></th>
<th class="head"><p>UNORM</p></th>
<th class="head"><p>SNORM</p></th>
<th class="head"><p>FLOAT</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>8</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Unsupported</p></td>
</tr>
<tr class="row-odd"><td><p>8_8</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Unsupported</p></td>
</tr>
<tr class="row-even"><td><p>8_8_8_8</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Unsupported</p></td>
</tr>
<tr class="row-odd"><td><p>16</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-even"><td><p>16_16</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-odd"><td><p>16_16_16_16</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-even"><td><p>32</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-odd"><td><p>32_32</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-even"><td><p>32_32_32_32</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-odd"><td><p>10_10_10_2</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-even"><td><p>11_11_10</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
<td><p>Required</p></td>
</tr>
<tr class="row-odd"><td><p>5_6_5</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
<td><p>Required</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
</tr>
<tr class="row-even"><td><p>5_5_5_1</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
<td><p>Required</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
</tr>
<tr class="row-odd"><td><p>4_4_4_4</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
<td><p>Required</p></td>
<td><p>Unsupported</p></td>
<td><p>Unsupported</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="device-cache-settings">
<h3>Device Cache Settings<a class="headerlink" href="#device-cache-settings" title="Permalink to this headline">¶</a></h3>
<p>There are two methods for device and kernel cache control:</p>
<ol class="arabic">
<li><p>Cache Size Configuration: Ability to configure larger size for SLM vs Data globally for Device or per Kernel instance.</p></li>
<li><p>Runtime Hint/preference for application to allow access to be Cached or not in Device Caches. For GPU device this is provided via two ways:</p>
<blockquote>
<div><ul class="simple">
<li><p>During Image creation via Flag</p></li>
<li><p>Kernel instruction</p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p>The following pseudo-code demonstrates a basic sequence for Cache size
configuration:</p>
<pre class="literal-block">// Large SLM for Intermediate and Last Level cache.
// Note: The intermediate cache setting is applied to each kernel. Last level is applied for the device.
<a class="reference internal" href="api.html#zekernelsetintermediatecacheconfig"><span class="std std-ref">zeKernelSetIntermediateCacheConfig</span></a>(hKernel, <a class="reference internal" href="api.html#ze-cache-config-t"><span class="std std-ref">ZE_CACHE_CONFIG_LARGE_SLM</span></a>);
<a class="reference internal" href="api.html#zedevicesetlastlevelcacheconfig"><span class="std std-ref">zeDeviceSetLastLevelCacheConfig</span></a>(hDevice, <a class="reference internal" href="api.html#ze-cache-config-t"><span class="std std-ref">ZE_CACHE_CONFIG_LARGE_SLM</span></a>);
...</pre>
</div>
</div>
<div class="section" id="command-queues-and-command-lists">
<h2>Command Queues and Command Lists<a class="headerlink" href="#command-queues-and-command-lists" title="Permalink to this headline">¶</a></h2>
<p>The following are the motivations for separating a command queue from a command list:</p>
<ul class="simple">
<li><p>Command queues are mostly associated with physical device properties, such as the number of input streams.</p></li>
<li><p>Command queues provide (near) zero-latency access to the device.</p></li>
<li><p>Command lists are mostly associated with Host threads for simultaneous construction.</p></li>
<li><p>Command list construction can occur independently of command queue submission.</p></li>
</ul>
<p>The following diagram illustrates the hierarchy of command lists and command queues to the device:</p>
<img alt="../_images/core_queue.png" src="../_images/core_queue.png" />
<div class="section" id="command-queues">
<h3>Command Queues<a class="headerlink" href="#command-queues" title="Permalink to this headline">¶</a></h3>
<p>A command queue represents a logical input stream to the device, tied to a physical input
stream.</p>
<div class="section" id="creation">
<h4>Creation<a class="headerlink" href="#creation" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>At creation time, the logical command queue is explicitly bound to a physical command queue.</p></li>
<li><p>The number and properties of physical command queues is queried by using <a class="reference internal" href="api.html#zedevicegetcommandqueuegroupproperties"><span class="std std-ref">zeDeviceGetCommandQueueGroupProperties</span></a>.</p></li>
<li><p>Multiple logical command queues may be created that use the same physical command queue. For example,
an application may create a logical command queue per Host thread with different scheduling priorities.</p></li>
<li><p>However, since each logical command queue may allocate a logical hardware context, an application
should avoid creating multiple logical command queues for the same physical command queue with the
same priority, due to possible performance penalties with hardware context switching.</p></li>
<li><p>The maximum number of logical command queues an application can create is limited by device-specific
resources; e.g., the maximum number of logical hardware contexts supported by the device.
This can be queried from <a class="reference internal" href="api.html#ze-device-properties-t"><span class="std std-ref">ze_device_properties_t</span></a>.maxHardwareContexts.</p></li>
<li><p>All command lists executed on a logical command queue are guaranteed to <strong>only</strong> execute on the physical
command queue which it is assigned; e.g., copy commands in a compute command list / queue will
execute via the compute engine, not the copy engine.</p></li>
</ul>
<p>The following pseudo-code demonstrates a basic sequence for creation of command queues:</p>
<pre class="literal-block">// Discover all command queue types
uint32_t cmdqueueGroupCount = 0;_
<a class="reference internal" href="api.html#zedevicegetcommandqueuegroupproperties"><span class="std std-ref">zeDeviceGetCommandQueueGroupProperties</span></a>(hDevice, &amp;cmdqueueGroupCount, nullptr);

<a class="reference internal" href="api.html#ze-command-queue-group-properties-t"><span class="std std-ref">ze_command_queue_group_properties_t</span></a>* cmdqueueGroupProperties = (<a class="reference internal" href="api.html#ze-command-queue-group-properties-t"><span class="std std-ref">ze_command_queue_group_properties_t</span></a>*)
    malloc(cmdqueueGroupCount * sizeof(<a class="reference internal" href="api.html#ze-command-queue-group-properties-t"><span class="std std-ref">ze_command_queue_group_properties_t</span></a>));
<a class="reference internal" href="api.html#zedevicegetcommandqueuegroupproperties"><span class="std std-ref">zeDeviceGetCommandQueueGroupProperties</span></a>(hDevice, &amp;cmdqueueGroupCount, allQueues);


// Find a proper command queue
for(uint32_t i = 0; i &lt; cmdqueueGroupCount; ++i) {
    if( cmdqueueGroupProperties.computeSupported ) {
        command_queue_ordinal = i;
        break;
    }
}

if(computeQueueGroupOrdinal == cmdqueueGroupCount)
    return; // no compute queues found

// Create a command queue
<a class="reference internal" href="api.html#ze-command-queue-desc-t"><span class="std std-ref">ze_command_queue_desc_t</span></a> commandQueueDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_COMMAND_QUEUE_DESC</span></a>,
    nullptr,
    computeQueueGroupOrdinal,
    0,
    <a class="reference internal" href="api.html#ze-command-queue-flag-t"><span class="std std-ref">ZE_COMMAND_QUEUE_FLAG_NONE</span></a>,
    <a class="reference internal" href="api.html#ze-command-queue-mode-t"><span class="std std-ref">ZE_COMMAND_QUEUE_MODE_DEFAULT</span></a>,
    <a class="reference internal" href="api.html#ze-command-queue-priority-t"><span class="std std-ref">ZE_COMMAND_QUEUE_PRIORITY_NORMAL</span></a>,
    0
};
ze_command_queue_handle_t hCommandQueue;
<a class="reference internal" href="api.html#zecommandqueuecreate"><span class="std std-ref">zeCommandQueueCreate</span></a>(hDevice, &amp;commandQueueDesc, &amp;hCommandQueue);
...</pre>
</div>
<div class="section" id="execution">
<h4>Execution<a class="headerlink" href="#execution" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>Command lists submitted to a command queue are <strong>immediately</strong> executed in a fifo manner.</p></li>
<li><p>Command queue submission is free-treaded, allowing multiple Host threads to
share the same command queue.</p></li>
<li><p>If multiple Host threads enter the same command queue simultaneously, then execution order
is undefined.</p></li>
<li><p>Command lists can only be executed on a command queue with an identical command queue group ordinal,
see more details below.</p></li>
<li><p>If a device contains multiple sub-devices, then command lists submitted to a device-level command queue
may be optimized by the driver to fully exploit the concurrency of the sub-devices by distributing command lists across sub-devices.
If the application prefers to opt-out of these optimizations, such as when the application plans to perform this distribution itself,
then it should use <a class="reference internal" href="api.html#ze-command-queue-flag-t"><span class="std std-ref">ZE_COMMAND_QUEUE_FLAG_EXPLICIT_ONLY</span></a>. Only command lists created using <a class="reference internal" href="api.html#ze-command-list-flag-t"><span class="std std-ref">ZE_COMMAND_LIST_FLAG_EXPLICIT_ONLY</span></a>
can be executed on a command queue created using <a class="reference internal" href="api.html#ze-command-queue-flag-t"><span class="std std-ref">ZE_COMMAND_QUEUE_FLAG_EXPLICIT_ONLY</span></a>.</p></li>
</ul>
</div>
<div class="section" id="destruction">
<h4>Destruction<a class="headerlink" href="#destruction" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>The application is responsible for making sure the device is not currently
executing from a command queue before it is deleted. This is
typically done by tracking command queue fences, but may also be
handled by calling <a class="reference internal" href="api.html#zecommandqueuesynchronize"><span class="std std-ref">zeCommandQueueSynchronize</span></a>.</p></li>
</ul>
</div>
</div>
<div class="section" id="command-lists">
<h3>Command Lists<a class="headerlink" href="#command-lists" title="Permalink to this headline">¶</a></h3>
<p>A command list represents a sequence of commands for execution on a command queue.</p>
<div class="section" id="creation-1">
<span id="id3"></span><h4>Creation<a class="headerlink" href="#creation-1" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>A command list is created for a device to allow device-specific appending of commands.</p></li>
<li><p>A command list is created for execution on a specific type of command queue, specified using
the command queue group ordinal.</p></li>
<li><p>A command list can be copied to create another command list. The application may use this
to copy a command list for use on a different device.</p></li>
</ul>
</div>
<div class="section" id="appending">
<h4>Appending<a class="headerlink" href="#appending" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>There is no implicit binding of command lists to Host threads. Therefore, an
application may share a command list handle across multiple Host threads. However,
the application is responsible for ensuring that multiple Host threads do not access
the same command list simultaneously.</p></li>
<li><p>By default, commands are started in the same order in which they are appended.
However, an application may allow the driver to optimize the ordering by using
<a class="reference internal" href="api.html#ze-command-list-flag-t"><span class="std std-ref">ZE_COMMAND_LIST_FLAG_RELAXED_ORDERING</span></a>. Reordering is guaranteed to only occur
between barriers and synchronization primitives.</p></li>
<li><p>By default, commands submitted to a command list are optimized for execution by
balancing both device throughput and Host latency.</p></li>
<li><p>For very low-level latency usage-models, applications should use immediate command lists.</p></li>
<li><p>For usage-models where maximum throughput is desired, applications should
use <a class="reference internal" href="api.html#ze-command-list-flag-t"><span class="std std-ref">ZE_COMMAND_LIST_FLAG_MAXIMIZE_THROUGHPUT</span></a>. This flag will indicate to the driver
it may perform additional device-specific optimizations.</p></li>
<li><p>If a device contains multiple sub-devices, then commands submitted to a device-level
command list may be optimized by the driver to fully exploit the concurrency of the
sub-devices by distributing commands across sub-devices. If the application prefers
to opt-out of these optimizations, such as when the application plans to perform this
distribution itself, then it should use <a class="reference internal" href="api.html#ze-command-list-flag-t"><span class="std std-ref">ZE_COMMAND_LIST_FLAG_EXPLICIT_ONLY</span></a>.</p></li>
</ul>
<p>The following pseudo-code demonstrates a basic sequence for creation of command lists:</p>
<pre class="literal-block">// Create a command list
<a class="reference internal" href="api.html#ze-command-list-desc-t"><span class="std std-ref">ze_command_list_desc_t</span></a> commandListDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_COMMAND_LIST_DESC</span></a>,
    nullptr,
    computeQueueGroupOrdinal,
    <a class="reference internal" href="api.html#ze-command-list-flag-t"><span class="std std-ref">ZE_COMMAND_LIST_FLAG_NONE</span></a>
};
ze_command_list_handle_t hCommandList;
<a class="reference internal" href="api.html#zecommandlistcreate"><span class="std std-ref">zeCommandListCreate</span></a>(hDevice, &amp;commandListDesc, &amp;hCommandList);
...</pre>
</div>
<div class="section" id="submission">
<h4>Submission<a class="headerlink" href="#submission" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>There is no implicit association between a command list and a logical command queue.
Therefore, a command list may be submitted to any or multiple logical command queues.</p></li>
<li><p>By definition, a command list cannot be executed concurrently on multiple physical command queues.</p></li>
<li><p>If a command list is meant to be submitted to a physical copy-only command queue,
then it must be created using a command queue group ordinal with its
<a class="reference internal" href="api.html#ze-command-queue-group-properties-t"><span class="std std-ref">ze_command_queue_group_properties_t</span></a>.copySupported equal true (1) and
<a class="reference internal" href="api.html#ze-command-queue-group-properties-t"><span class="std std-ref">ze_command_queue_group_properties_t</span></a>.computeSupported equal false (0), and submitted to a logical command
queue created using the same ordinal.</p></li>
<li><p>The application is responsible for calling close before submission to a command queue.</p></li>
<li><p>Command lists do not inherit state from other command lists executed on the same
command queue.  i.e. each command list begins execution in its own default state.</p></li>
<li><p>A command list may be submitted multiple times.  It is up to the application to ensure
that the command list can be executed multiple times.
For example, event must be explicitly reset prior to re-execution.</p></li>
</ul>
<p>The following pseudo-code demonstrates submission of commands to a command queue, via a command list:</p>
<pre class="literal-block">...
// finished appending commands (typically done on another thread)
<a class="reference internal" href="api.html#zecommandlistclose"><span class="std std-ref">zeCommandListClose</span></a>(hCommandList);

// Execute command list in command queue
<a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a>(hCommandQueue, 1, &amp;hCommandList, nullptr);

// synchronize host and device
<a class="reference internal" href="api.html#zecommandqueuesynchronize"><span class="std std-ref">zeCommandQueueSynchronize</span></a>(hCommandQueue, UINT32_MAX);

// Reset (recycle) command list for new commands
<a class="reference internal" href="api.html#zecommandlistreset"><span class="std std-ref">zeCommandListReset</span></a>(hCommandList);
...</pre>
</div>
<div class="section" id="recycling">
<h4>Recycling<a class="headerlink" href="#recycling" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><p>A command list may be recycled to avoid the overhead of frequent creation and destruction.</p></li>
<li><p>The application is responsible for making sure the device is not currently
executing from a command list before it is reset. This should be
handled by tracking a completion event associated with the command list.</p></li>
<li><p>The application is responsible for making sure the device is not currently
executing from a command list before it is deleted. This should be
handled by tracking a completion event associated with the command list.</p></li>
</ul>
</div>
<div class="section" id="low-latency-immediate-command-lists">
<h4>Low-Latency Immediate Command Lists<a class="headerlink" href="#low-latency-immediate-command-lists" title="Permalink to this headline">¶</a></h4>
<p>A special type of command list can be used for very low-latency submission usage-models.</p>
<ul class="simple">
<li><p>An immediate command list is both a command list and an implicit command queue.</p></li>
<li><p>An immediate command list is created using a command queue descriptor.</p></li>
<li><p>Commands submitted to an immediate command list are immediately executed on the device.</p></li>
<li><p>An immediate command list is not required to be closed or reset. However, usage will be honored, and expected behaviors will be followed.</p></li>
</ul>
<p>The following pseudo-code demonstrates a basic sequence for creation and usage of immediate command lists:</p>
<pre class="literal-block">// Create an immediate command list
<a class="reference internal" href="api.html#ze-command-queue-desc-t"><span class="std std-ref">ze_command_queue_desc_t</span></a> commandQueueDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_COMMAND_QUEUE_DESC</span></a>,
    nullptr,
    computeQueueGroupOrdinal,
    <a class="reference internal" href="api.html#ze-command-queue-flag-t"><span class="std std-ref">ZE_COMMAND_QUEUE_FLAG_NONE</span></a>,
    <a class="reference internal" href="api.html#ze-command-queue-mode-t"><span class="std std-ref">ZE_COMMAND_QUEUE_MODE_DEFAULT</span></a>,
    <a class="reference internal" href="api.html#ze-command-queue-priority-t"><span class="std std-ref">ZE_COMMAND_QUEUE_PRIORITY_NORMAL</span></a>,
    0
};
ze_command_list_handle_t hCommandList;
<a class="reference internal" href="api.html#zecommandlistcreateimmediate"><span class="std std-ref">zeCommandListCreateImmediate</span></a>(hDevice, &amp;commandQueueDesc, &amp;hCommandList);

// Immediately submit a kernel to the device
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);
...</pre>
</div>
</div>
</div>
<div class="section" id="synchronization-primitives">
<h2>Synchronization Primitives<a class="headerlink" href="#synchronization-primitives" title="Permalink to this headline">¶</a></h2>
<p>There are two types of synchronization primitives:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#fences">Fences</a> - used to communicate to the host that command queue execution has completed.</p></li>
<li><p><a class="reference internal" href="#events">Events</a> - used as fine-grain host-to-device, device-to-host or device-to-device execution and memory dependencies.</p></li>
</ol>
<p>The following are the motivations for separating the different types of synchronization primitives:</p>
<ul>
<li><p>Allows device-specific optimizations for certain types of primitives:</p>
<blockquote>
<div><ul class="simple">
<li><p>Fences may share device memory with all other fences within the same command queue.</p></li>
<li><p>Events may be implemented using pipelined operations as part of the program execution.</p></li>
<li><p>Fences are implicit, coarse-grain execution and memory barriers.</p></li>
<li><p>Events optionally cause fine-grain execution and memory barriers.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Allows distinction on which type of primitive may be shared across devices.</p></li>
</ul>
<p>Generally. Events are generic synchronization primitives that can be used across many different usage-models, including those of fences.
However, this generality comes with some cost in memory overhead and efficiency.</p>
<div class="section" id="fences">
<span id="id4"></span><h3>Fences<a class="headerlink" href="#fences" title="Permalink to this headline">¶</a></h3>
<p>A fence is a heavyweight synchronization primitive used to communicate to the host that command list execution has completed.</p>
<ul class="simple">
<li><p>A fence is associated with a single command queue.</p></li>
<li><p>A fence can only be signaled from a device’s command queue (e.g. between execution of command lists) and can only be waited upon from the host.</p></li>
<li><p>A fence guarantees both execution completion and memory coherency, across the device and host, prior to being signaled.</p></li>
<li><p>A fence only has two states: not signaled and signaled.</p></li>
<li><p>A fence doesn’t implicitly reset. Signaling a signaled fence (or resetting an unsignaled fence) is valid and has no effect on the state of the fence.</p></li>
<li><p>A fence can only be reset from the Host.</p></li>
<li><p>A fence cannot be shared across processes.</p></li>
</ul>
<p>The following pseudo-code demonstrates a sequence for creation, submission and querying of a fence:</p>
<pre class="literal-block">// Create fence
<a class="reference internal" href="api.html#ze-fence-desc-t"><span class="std std-ref">ze_fence_desc_t</span></a> fenceDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_FENCE_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-fence-flag-t"><span class="std std-ref">ZE_FENCE_FLAG_NONE</span></a>
};
ze_fence_handle_t hFence;
<a class="reference internal" href="api.html#zefencecreate"><span class="std std-ref">zeFenceCreate</span></a>(hCommandQueue, &amp;fenceDesc, &amp;hFence);

// Execute a command list with a signal of the fence
<a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a>(hCommandQueue, 1, &amp;hCommandList, hFence);

// Wait for fence to be signaled
<a class="reference internal" href="api.html#zefencehostsynchronize"><span class="std std-ref">zeFenceHostSynchronize</span></a>(hFence, UINT32_MAX);
<a class="reference internal" href="api.html#zefencereset"><span class="std std-ref">zeFenceReset</span></a>(hFence);
...</pre>
<p>The primary usage model for fences is to notify the Host when a command list has finished execution to allow:</p>
<ul class="simple">
<li><p>Recycling of memory and images</p></li>
<li><p>Recycling of command lists</p></li>
<li><p>Recycling of other synchronization primitives</p></li>
<li><p>Explicit memory residency.</p></li>
</ul>
<p>The following diagram illustrates fences signaled after command lists on execution:</p>
<img alt="../_images/core_fence.png" src="../_images/core_fence.png" />
</div>
<div class="section" id="events">
<span id="id5"></span><h3>Events<a class="headerlink" href="#events" title="Permalink to this headline">¶</a></h3>
<p>An event is used to communicate fine-grain host-to-device, device-to-host or device-to-device dependencies have completed.</p>
<ul>
<li><p>An event can be:</p>
<blockquote>
<div><ul class="simple">
<li><p>Signaled from within a device’s command list and waited upon within the same command list</p></li>
<li><p>Signaled from within a device’s command list and waited upon from the host, another command queue or another device</p></li>
<li><p>Signaled from the host, and waited upon from within a device’s command list.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>An event only has two states: not signaled and signaled.</p></li>
<li><p>An event doesn’t implicitly reset. Signaling a signaled event (or resetting an unsignaled event) is valid and has no effect on the state of the event.</p></li>
<li><p>An event can be explicitly reset from the Host or device.</p></li>
<li><p>An event can be appended into multiple command lists simultaneously.</p></li>
<li><p>An event can be shared across devices and processes.</p></li>
<li><p>An event can invoke an execution and/or memory barrier; which should be used sparingly to avoid device underutilization.</p></li>
<li><p>There are no protections against events causing deadlocks, such as circular waits scenarios.</p>
<blockquote>
<div><ul class="simple">
<li><p>These problems are left to the application to avoid.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>An event intended to be signaled by the host, another command queue or another device after command list submission to a command queue may prevent subsequent forward progress within the command queue itself.</p>
<blockquote>
<div><ul class="simple">
<li><p>This can create bubbles in the pipeline or deadlock situations if not correctly scheduled.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>An event pool is used for creation of individual events:</p>
<ul class="simple">
<li><p>An event pool reduces the cost of creating multiple events by allowing underlying device allocations to be shared by events with the same properties</p></li>
<li><p>An event pool can be shared via <a class="reference internal" href="#inter-process-communication"><span class="std std-ref">Inter-Process Communication</span></a>; allowing sharing blocks of events rather than sharing each individual event</p></li>
</ul>
<p>The following pseudo-code demonstrates a sequence for creation and submission of an event:</p>
<pre class="literal-block">// Create event pool
<a class="reference internal" href="api.html#ze-event-pool-desc-t"><span class="std std-ref">ze_event_pool_desc_t</span></a> eventPoolDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_POOL_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-event-pool-flag-t"><span class="std std-ref">ZE_EVENT_POOL_FLAG_HOST_VISIBLE</span></a>, // all events in pool are visible to Host
    1
};
ze_event_pool_handle_t hEventPool;
<a class="reference internal" href="api.html#zeeventpoolcreate"><span class="std std-ref">zeEventPoolCreate</span></a>(hDriver, &amp;eventPoolDesc, 0, nullptr, &amp;hEventPool);

<a class="reference internal" href="api.html#ze-event-desc-t"><span class="std std-ref">ze_event_desc_t</span></a> eventDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_DESC</span></a>,
    nullptr,
    0,
    <a class="reference internal" href="api.html#ze-event-scope-flag-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_NONE</span></a>,
    <a class="reference internal" href="api.html#ze-event-scope-flag-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_HOST</span></a>  // ensure memory coherency across device and Host after event completes
};
ze_event_handle_t hEvent;
<a class="reference internal" href="api.html#zeeventcreate"><span class="std std-ref">zeEventCreate</span></a>(hEventPool, &amp;eventDesc, &amp;hEvent);

// Append a signal of an event into the command list after the kernel executes
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel1, &amp;launchArgs, hEvent, 0, nullptr);

// Execute the command list with the signal
<a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a>(hCommandQueue, 1, &amp;hCommandList, nullptr);

// Wait on event to complete
<a class="reference internal" href="api.html#zeeventhostsynchronize"><span class="std std-ref">zeEventHostSynchronize</span></a>(hEvent, 0);
...</pre>
<p>The following diagram illustrates a dependency between command lists using events:</p>
<img alt="../_images/core_event.png" src="../_images/core_event.png" />
<div class="section" id="kernel-timestamp-events">
<h4>Kernel Timestamp Events<a class="headerlink" href="#kernel-timestamp-events" title="Permalink to this headline">¶</a></h4>
<p>A kernel timestamp event is a special type of event that records device timestamps at the start and end of the execution of kernels.</p>
<ul class="simple">
<li><p>A kernel timestamp event can only be signaled from <a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a> et al. functions</p></li>
<li><p>A kernel timestamp event result can be queried using either <a class="reference internal" href="api.html#zeeventquerykerneltimestamp"><span class="std std-ref">zeEventQueryKernelTimestamp</span></a> or <a class="reference internal" href="api.html#zecommandlistappendquerykerneltimestamps"><span class="std std-ref">zeCommandListAppendQueryKernelTimestamps</span></a></p></li>
<li><p>The <a class="reference internal" href="api.html#ze-kernel-timestamp-result-t"><span class="std std-ref">ze_kernel_timestamp_result_t</span></a> contains both the per-context and global timestamp values at the start and end of the kernel’s execution</p></li>
<li><p>Since these counters are only 32bits, the application must detect and handle counter wrapping when calculating execution time</p></li>
</ul>
<pre class="literal-block">// Get timestamp frequency
const uint64_t timestampFreq = device_properties.timerResolution;
const uint64_t timestampMaxValue = ~(-1 &lt;&lt; device_properties.kernelTimestampValidBits);

// Create event pool
<a class="reference internal" href="api.html#ze-event-pool-desc-t"><span class="std std-ref">ze_event_pool_desc_t</span></a> tsEventPoolDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_POOL_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-event-pool-flag-t"><span class="std std-ref">ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP</span></a>, // all events in pool are kernel timestamps
    1
};
ze_event_pool_handle_t hTSEventPool;
<a class="reference internal" href="api.html#zeeventpoolcreate"><span class="std std-ref">zeEventPoolCreate</span></a>(hDriver, &amp;tsEventPoolDesc, 0, nullptr, &amp;hTSEventPool);

<a class="reference internal" href="api.html#ze-event-desc-t"><span class="std std-ref">ze_event_desc_t</span></a> tsEventDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_DESC</span></a>,
    nullptr,
    0,
    <a class="reference internal" href="api.html#ze-event-scope-flag-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_NONE</span></a>,
    <a class="reference internal" href="api.html#ze-event-scope-flag-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_NONE</span></a>
};
ze_event_handle_t hTSEvent;
<a class="reference internal" href="api.html#zeeventcreate"><span class="std std-ref">zeEventCreate</span></a>(hEventPool, &amp;tsEventDesc, &amp;hTSEvent);

// allocate memory for results
<a class="reference internal" href="api.html#ze-device-mem-alloc-desc-t"><span class="std std-ref">ze_device_mem_alloc_desc_t</span></a> tsResultDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_DEVICE_MEM_ALLOC_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-device-mem-alloc-flag-t"><span class="std std-ref">ZE_DEVICE_MEM_ALLOC_FLAG_DEFAULT</span></a>,
    0
};
<a class="reference internal" href="api.html#ze-kernel-timestamp-result-t"><span class="std std-ref">ze_kernel_timestamp_result_t</span></a>* tsResult = nullptr;
<a class="reference internal" href="api.html#zedriverallocdevicemem"><span class="std std-ref">zeDriverAllocDeviceMem</span></a>(hDriver, &amp;tsResultDesc, sizeof(<a class="reference internal" href="api.html#ze-kernel-timestamp-result-t"><span class="std std-ref">ze_kernel_timestamp_result_t</span></a>), sizeof(uint32_t), hDevice, &amp;tsResult);

// Append a signal of a timestamp event into the command list after the kernel executes
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel1, &amp;launchArgs, hTSEvent, 0, nullptr);

// Append a query of a timestamp event into the command list
<a class="reference internal" href="api.html#zecommandlistappendquerykerneltimestamps"><span class="std std-ref">zeCommandListAppendQueryKernelTimestamps</span></a>(hCommandList, 1, &amp;hTSEvent, tsResult, nullptr, hEvent, 1, &amp;hTSEvent);

// Execute the command list with the signal
<a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a>(hCommandQueue, 1, &amp;hCommandList, nullptr);

// Wait on event to complete
<a class="reference internal" href="api.html#zeeventhostsynchronize"><span class="std std-ref">zeEventHostSynchronize</span></a>(hEvent, 0);

// Calculation execution time(s)
double globalTimeInNs = ( tsResult-&gt;global.kernelEnd &gt;= tsResult-&gt;global.kernelStart )
    ? ( tsResult-&gt;global.kernelEnd - tsResult-&gt;global.kernelStart ) * (double)timestampFreq
    : (( timestampMaxValue - tsResult-&gt;global.kernelStart) + tsResult-&gt;global.kernelEnd + 1 ) * (double)timestampFreq;

double contextTimeInNs = ( tsResult-&gt;context.kernelEnd &gt;= tsResult-&gt;context.kernelStart )
    ? ( tsResult-&gt;context.kernelEnd - tsResult-&gt;context.kernelStart ) * (double)timestampFreq
    : (( timestampMaxValue - tsResult-&gt;context.kernelStart) + tsResult-&gt;context.kernelEnd + 1 ) * (double)timestampFreq;
...</pre>
</div>
</div>
</div>
<div class="section" id="barriers">
<h2>Barriers<a class="headerlink" href="#barriers" title="Permalink to this headline">¶</a></h2>
<p>There are two types of barriers:</p>
<ol class="arabic simple">
<li><p><strong>Execution Barriers</strong> - used to communicate execution dependencies between commands within a command list or across command queues, devices and/or Host.</p></li>
<li><p><strong>Memory Barriers</strong> - used to communicate memory coherency dependencies between commands within a command list or across command queues, devices and/or Host.</p></li>
</ol>
<p>The following pseudo-code demonstrates a sequence for submission of a brute-force execution and global memory barrier:</p>
<pre class="literal-block"><a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);

// Append a barrier into a command list to ensure hKernel1 completes before hKernel2 begins
<a class="reference internal" href="api.html#zecommandlistappendbarrier"><span class="std std-ref">zeCommandListAppendBarrier</span></a>(hCommandList, nullptr, 0, nullptr);

<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);
...</pre>
<div class="section" id="execution-barriers">
<h3>Execution Barriers<a class="headerlink" href="#execution-barriers" title="Permalink to this headline">¶</a></h3>
<p>Commands executed on a command list are only guaranteed to start in the same order in which they are submitted; i.e. there is no implicit definition of the order of completion.</p>
<ul class="simple">
<li><p>Fences provide implicit, coarse-grain control to indicate that all previous commands must complete prior to the fence being signaled.</p></li>
<li><p>Events provide explicit, fine-grain control over execution dependencies between commands; allowing more opportunities for concurrent execution and higher device utilization.</p></li>
</ul>
<p>The following pseudo-code demonstrates a sequence for submission of a fine-grain execution-only dependency using events:</p>
<pre class="literal-block"><a class="reference internal" href="api.html#ze-event-desc-t"><span class="std std-ref">ze_event_desc_t</span></a> event1Desc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_DESC</span></a>,
    nullptr,
    0,
    <a class="reference internal" href="api.html#ze-event-scope-flag-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_NONE</span></a>, // no memory/cache coherency required on signal
    <a class="reference internal" href="api.html#ze-event-scope-flag-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_NONE</span></a>  // no memory/cache coherency required on wait
};
ze_event_handle_t hEvent1;
<a class="reference internal" href="api.html#zeeventcreate"><span class="std std-ref">zeEventCreate</span></a>(hEventPool, &amp;event1Desc, &amp;hEvent1);

// Ensure hKernel1 completes before signaling hEvent1
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel1, &amp;launchArgs, hEvent1, 0, nullptr);

// Ensure hEvent1 is signaled before starting hKernel2
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel2, &amp;launchArgs, nullptr, 1, &amp;hEvent1);
...</pre>
</div>
<div class="section" id="memory-barriers">
<h3>Memory Barriers<a class="headerlink" href="#memory-barriers" title="Permalink to this headline">¶</a></h3>
<p>Commands executed on a command list are <em>not</em> guaranteed to maintain memory coherency with other commands;
i.e. there is no implicit memory or cache coherency.</p>
<ul class="simple">
<li><p>Fences provide implicit, coarse-grain control to indicate that all caches and memory are coherent across the device and Host prior to the fence being signaled.</p></li>
<li><p>Events provide explicit, fine-grain control over cache and memory coherency dependencies between commands; allowing more opportunities for concurrent execution and higher device utilization.</p></li>
</ul>
<p>The following pseudo-code demonstrates a sequence for submission of a fine-grain memory dependency using events:</p>
<pre class="literal-block"><a class="reference internal" href="api.html#ze-event-desc-t"><span class="std std-ref">ze_event_desc_t</span></a> event1Desc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_DESC</span></a>,
    nullptr,
    0,
    <a class="reference internal" href="api.html#ze-event-scope-flag-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_DEVICE</span></a>, // ensure memory coherency across device before event signaled
    <a class="reference internal" href="api.html#ze-event-scope-flag-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_NONE</span></a>
};
ze_event_handle_t hEvent1;
<a class="reference internal" href="api.html#zeeventcreate"><span class="std std-ref">zeEventCreate</span></a>(hEventPool, &amp;event1Desc, &amp;hEvent1);

// Ensure hKernel1 memory writes are fully coherent across the device before signaling hEvent1
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel1, &amp;launchArgs, hEvent1, 0, nullptr);

// Ensure hEvent1 is signaled before starting hKernel2
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel2, &amp;launchArgs, nullptr, 1, &amp;hEvent1);
...</pre>
</div>
<div class="section" id="range-based-memory-barriers">
<h3>Range-based Memory Barriers<a class="headerlink" href="#range-based-memory-barriers" title="Permalink to this headline">¶</a></h3>
<p>Range-based memory barriers provide explicit control of which cachelines
require coherency.</p>
<p>The following pseudo-code demonstrates a sequence for submission of a range-based memory barrier:</p>
<pre class="literal-block"><a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel1, &amp;launchArgs, nullptr, 0, nullptr);

// Ensure memory range is fully coherent across the device after hKernel1 and before hKernel2
<a class="reference internal" href="api.html#zecommandlistappendmemoryrangesbarrier"><span class="std std-ref">zeCommandListAppendMemoryRangesBarrier</span></a>(hCommandList, 1, &amp;size, &amp;ptr, nullptr, 0, nullptr);

<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel2, &amp;launchArgs, nullptr, 0, nullptr);
...</pre>
</div>
</div>
<div class="section" id="modules-and-kernels">
<h2>Modules and Kernels<a class="headerlink" href="#modules-and-kernels" title="Permalink to this headline">¶</a></h2>
<p>There are multiple levels of constructs needed for executing kernels on the device:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#modules">Modules</a> represent a single translation unit that consists of kernels that have been compiled together.</p></li>
<li><p><a class="reference internal" href="#kernels">Kernels</a> represent the kernel within the module that will be launched directly from a command list.</p></li>
</ol>
<p>The following diagram provides a high-level overview of the major parts
of the system.</p>
<img alt="../_images/core_module.png" src="../_images/core_module.png" />
<div class="section" id="modules">
<span id="id6"></span><h3>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h3>
<p>Modules can be created from an IL or directly from native format using <a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a>.</p>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a> takes a format argument that specifies the input format.</p></li>
<li><p><a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a> performs a compilation step when format is IL.</p></li>
</ul>
<p>The following pseudo-code demonstrates a sequence for creating a module from an OpenCL kernel:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">__kernel</span> <span class="kt">void</span> <span class="nf">image_scaling</span><span class="p">(</span> <span class="n">__read_only</span>  <span class="n">image2d_t</span> <span class="n">src_img</span><span class="p">,</span>
                             <span class="n">__write_only</span> <span class="n">image2d_t</span> <span class="n">dest_img</span><span class="p">,</span>
                                          <span class="n">uint</span> <span class="n">WIDTH</span><span class="p">,</span>     <span class="c1">// resized width</span>
                                          <span class="n">uint</span> <span class="n">HEIGHT</span> <span class="p">)</span>   <span class="c1">// resized height</span>
<span class="p">{</span>
    <span class="n">int2</span>       <span class="n">coor</span> <span class="o">=</span> <span class="p">(</span><span class="n">int2</span><span class="p">)(</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">get_global_id</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">float2</span> <span class="n">normCoor</span> <span class="o">=</span> <span class="n">convert_float2</span><span class="p">(</span><span class="n">coor</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">float2</span><span class="p">)(</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span> <span class="p">);</span>

    <span class="n">float4</span>    <span class="n">color</span> <span class="o">=</span> <span class="n">read_imagef</span><span class="p">(</span> <span class="n">src_img</span><span class="p">,</span> <span class="n">SMPL_PREF</span><span class="p">,</span> <span class="n">normCoor</span> <span class="p">);</span>

    <span class="n">write_imagef</span><span class="p">(</span> <span class="n">dest_img</span><span class="p">,</span> <span class="n">coor</span><span class="p">,</span> <span class="n">color</span> <span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<pre class="literal-block">// OpenCL C kernel has been compiled to SPIRV IL (pImageScalingIL)
<a class="reference internal" href="api.html#ze-module-desc-t"><span class="std std-ref">ze_module_desc_t</span></a> moduleDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_MODULE_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-module-format-t"><span class="std std-ref">ZE_MODULE_FORMAT_IL_SPIRV</span></a>,
    ilSize,
    pImageScalingIL,
    nullptr,
    nullptr
};
ze_module_handle_t hModule;
<a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a>(hDevice, &amp;moduleDesc, &amp;hModule, nullptr);
...</pre>
<div class="section" id="module-build-options">
<h4>Module Build Options<a class="headerlink" href="#module-build-options" title="Permalink to this headline">¶</a></h4>
<p>Module build options can be passed with <a class="reference internal" href="api.html#ze-module-desc-t"><span class="std std-ref">ze_module_desc_t</span></a> as a string.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 36%" />
<col style="width: 43%" />
<col style="width: 8%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Build Option</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Device Support</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>-ze-opt-disable</p></td>
<td><p>Disable optimizations.</p></td>
<td><p>Disabled</p></td>
<td><p>All</p></td>
</tr>
<tr class="row-odd"><td><p>-ze-opt-greater-than-4GB-buffer-required</p></td>
<td><p>Use 64-bit offset calculations for buffers.</p></td>
<td><p>Disabled</p></td>
<td><p>GPU</p></td>
</tr>
<tr class="row-even"><td><p>-ze-opt-large-register-file</p></td>
<td><p>Increase number of registers available to threads.</p></td>
<td><p>Disabled</p></td>
<td><p>GPU</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="module-specialization-constants">
<h4>Module Specialization Constants<a class="headerlink" href="#module-specialization-constants" title="Permalink to this headline">¶</a></h4>
<p>SPIR-V supports specialization constants that allow certain constants to be updated to new
values during runtime execution. Each specialization constant in SPIR-V has an identifier
and default value. The <a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a> function allows for an array of constants and their
corresponding identifiers to be passed in to override the constants in the SPIR-V module.</p>
<pre class="literal-block">// Spec constant overrides for group size.
<a class="reference internal" href="api.html#ze-module-constants-t"><span class="std std-ref">ze_module_constants_t</span></a> specConstants = {
    3,
    pGroupSizeIds,
    pGroupSizeValues
};
// OpenCL C kernel has been compiled to SPIRV IL (pImageScalingIL)
<a class="reference internal" href="api.html#ze-module-desc-t"><span class="std std-ref">ze_module_desc_t</span></a> moduleDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_MODULE_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-module-format-t"><span class="std std-ref">ZE_MODULE_FORMAT_IL_SPIRV</span></a>,
    ilSize,
    pImageScalingIL,
    nullptr,
    &amp;specConstants
};
ze_module_handle_t hModule;
<a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a>(hDevice, &amp;moduleDesc, &amp;hModule, nullptr);
...</pre>
<p>Note: Specialization constants are only handled at module create time and therefore if
you need to change them then you’ll need to compile a new module.</p>
</div>
<div class="section" id="module-build-log">
<h4>Module Build Log<a class="headerlink" href="#module-build-log" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a> function can optionally generate a build log object ze_module_build_log_handle_t.</p>
<pre class="literal-block">...
ze_module_build_log_handle_t buildlog;
<a class="reference internal" href="api.html#ze-result-t"><span class="std std-ref">ze_result_t</span></a> result = <a class="reference internal" href="api.html#zemodulecreate"><span class="std std-ref">zeModuleCreate</span></a>(hDevice, &amp;desc, &amp;module, &amp;buildlog);

// Only save build logs for module creation errors.
if (result != <a class="reference internal" href="api.html#ze-result-t"><span class="std std-ref">ZE_RESULT_SUCCESS</span></a>)
{
    size_t szLog = 0;
    <a class="reference internal" href="api.html#zemodulebuildloggetstring"><span class="std std-ref">zeModuleBuildLogGetString</span></a>(buildlog, &amp;szLog, nullptr);

    char_t* strLog = allocate(szLog);
    <a class="reference internal" href="api.html#zemodulebuildloggetstring"><span class="std std-ref">zeModuleBuildLogGetString</span></a>(buildlog, &amp;szLog, strLog);

    // Save log to disk.
    ...

    free(strLog);
}

<a class="reference internal" href="api.html#zemodulebuildlogdestroy"><span class="std std-ref">zeModuleBuildLogDestroy</span></a>(buildlog);</pre>
</div>
<div class="section" id="module-caching-with-native-binaries">
<h4>Module Caching with Native Binaries<a class="headerlink" href="#module-caching-with-native-binaries" title="Permalink to this headline">¶</a></h4>
<p>Disk caching of modules is not supported by the driver. If a disk cache for modules is desired, then it is the
responsibility of the application to implement this using <a class="reference internal" href="api.html#zemodulegetnativebinary"><span class="std std-ref">zeModuleGetNativeBinary</span></a>.</p>
<pre class="literal-block">...
// compute hash for pIL and check cache.
...

if (cacheUpdateNeeded)
{
    size_t szBinary = 0;
    <a class="reference internal" href="api.html#zemodulegetnativebinary"><span class="std std-ref">zeModuleGetNativeBinary</span></a>(hModule, &amp;szBinary, nullptr);

    uint8_t* pBinary = allocate(szBinary);
    <a class="reference internal" href="api.html#zemodulegetnativebinary"><span class="std std-ref">zeModuleGetNativeBinary</span></a>(hModule, &amp;szBinary, pBinary);

    // cache pBinary for corresponding IL
    ...

    free(pBinary);
}</pre>
<p>Also, note that the native binary will retain all debug information that is associated with the module. This allows debug
capabilities for modules that are created from native binaries.</p>
</div>
<div class="section" id="built-in-kernels">
<h4>Built-in Kernels<a class="headerlink" href="#built-in-kernels" title="Permalink to this headline">¶</a></h4>
<p>Built-in kernels are not supported but can be implemented by an upper level runtime or library using the native binary
interface.</p>
</div>
</div>
<div class="section" id="kernels">
<span id="id7"></span><h3>Kernels<a class="headerlink" href="#kernels" title="Permalink to this headline">¶</a></h3>
<p>A Kernel is a reference to a kernel within a module and it supports both explicit and implicit kernel
arguments along with data needed for launch.</p>
<p>The following pseudo-code demonstrates a sequence for creating a kernel from a module:</p>
<pre class="literal-block"><a class="reference internal" href="api.html#ze-kernel-desc-t"><span class="std std-ref">ze_kernel_desc_t</span></a> kernelDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_KERNEL_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-kernel-flag-t"><span class="std std-ref">ZE_KERNEL_FLAG_NONE</span></a>,
    &quot;image_scaling&quot;
};
ze_kernel_handle_t hKernel;
<a class="reference internal" href="api.html#zekernelcreate"><span class="std std-ref">zeKernelCreate</span></a>(hModule, &amp;kernelDesc, &amp;hKernel);
...</pre>
<div class="section" id="kernel-attributes-and-properties">
<h4>Kernel Attributes and Properties<a class="headerlink" href="#kernel-attributes-and-properties" title="Permalink to this headline">¶</a></h4>
<p>Use <a class="reference internal" href="api.html#zekernelsetattribute"><span class="std std-ref">zeKernelSetAttribute</span></a> to set attributes for a Kernel.</p>
<pre class="literal-block">// Kernel performs indirect device access.
bool_t isIndirect = true;
<a class="reference internal" href="api.html#zekernelsetattribute"><span class="std std-ref">zeKernelSetAttribute</span></a>(hKernel, <a class="reference internal" href="api.html#ze-kernel-attribute-t"><span class="std std-ref">ZE_KERNEL_ATTRIBUTE_INDIRECT_DEVICE_ACCESS</span></a>, sizeof(bool_t), &amp;isIndirect);
...</pre>
<p>Use <a class="reference internal" href="api.html#zekernelsetattribute"><span class="std std-ref">zeKernelSetAttribute</span></a> to get attributes for a Kernel.</p>
<pre class="literal-block">// Does kernel perform indirect device access.
<a class="reference internal" href="api.html#zekernelgetattribute"><span class="std std-ref">zeKernelGetAttribute</span></a>(hKernel, <a class="reference internal" href="api.html#ze-kernel-attribute-t"><span class="std std-ref">ZE_KERNEL_ATTRIBUTE_INDIRECT_DEVICE_ACCESS</span></a>, sizeof(bool_t), &amp;isIndirect);
...

uint32_t strSize = 0; // Size of string + null terminator
<a class="reference internal" href="api.html#zekernelgetattribute"><span class="std std-ref">zeKernelGetAttribute</span></a>(hKernel, <a class="reference internal" href="api.html#ze-kernel-attribute-t"><span class="std std-ref">ZE_KERNEL_ATTRIBUTE_SOURCE_ATTRIBUTE</span></a>, &amp;strSize, nullptr );
char* pAttributes = allocate(strSize);
<a class="reference internal" href="api.html#zekernelgetattribute"><span class="std std-ref">zeKernelGetAttribute</span></a>(hKernel, <a class="reference internal" href="api.html#ze-kernel-attribute-t"><span class="std std-ref">ZE_KERNEL_ATTRIBUTE_SOURCE_ATTRIBUTE</span></a>, &amp;strSize, pAttributes );
...</pre>
<p>See <a class="reference internal" href="api.html#ze-kernel-attribute-t"><span class="std std-ref">ze_kernel_attribute_t</span></a> for more information on the “set” and “get” attributes.</p>
<p>Use <a class="reference internal" href="api.html#zekernelgetproperties"><span class="std std-ref">zeKernelGetProperties</span></a> to query invariant properties from a Kernel object.</p>
<pre class="literal-block">...
<a class="reference internal" href="api.html#ze-kernel-properties-t"><span class="std std-ref">ze_kernel_properties_t</span></a> kernelProperties;

//
<a class="reference internal" href="api.html#zekernelgetproperties"><span class="std std-ref">zeKernelGetProperties</span></a>(hKernel, &amp;kernelProperties);
...</pre>
<p>See <a class="reference internal" href="api.html#ze-kernel-properties-t"><span class="std std-ref">ze_kernel_properties_t</span></a> for more information for kernel properties.</p>
</div>
</div>
<div class="section" id="execution-1">
<span id="id8"></span><h3>Execution<a class="headerlink" href="#execution-1" title="Permalink to this headline">¶</a></h3>
<div class="section" id="kernel-group-size">
<h4>Kernel Group Size<a class="headerlink" href="#kernel-group-size" title="Permalink to this headline">¶</a></h4>
<p>The group size for a kernel can be set using <a class="reference internal" href="api.html#zekernelsetgroupsize"><span class="std std-ref">zeKernelSetGroupSize</span></a>. If a group size is not
set prior to appending a kernel into a command list then a default will be chosen.
The group size can be updated over a series of append operations. The driver will copy the
group size information when appending the kernel into the command list.</p>
<pre class="literal-block"><a class="reference internal" href="api.html#zekernelsetgroupsize"><span class="std std-ref">zeKernelSetGroupSize</span></a>(hKernel, groupSizeX, groupSizeY, 1);

...</pre>
<p>The API supports a query for suggested group size when providing the global size. This function ignores the
group size that was set on the kernel using <a class="reference internal" href="api.html#zekernelsetgroupsize"><span class="std std-ref">zeKernelSetGroupSize</span></a>.</p>
<pre class="literal-block">// Find suggested group size for processing image.
uint32_t groupSizeX;
uint32_t groupSizeY;
<a class="reference internal" href="api.html#zekernelsuggestgroupsize"><span class="std std-ref">zeKernelSuggestGroupSize</span></a>(hKernel, imageWidth, imageHeight, 1, &amp;groupSizeX, &amp;groupSizeY, nullptr);

<a class="reference internal" href="api.html#zekernelsetgroupsize"><span class="std std-ref">zeKernelSetGroupSize</span></a>(hKernel, groupSizeX, groupSizeY, 1);

...</pre>
</div>
<div class="section" id="kernel-arguments">
<h4>Kernel Arguments<a class="headerlink" href="#kernel-arguments" title="Permalink to this headline">¶</a></h4>
<p>Kernel arguments represent only the explicit kernel arguments that are within brackets e.g. func(arg1, arg2, …).</p>
<ul class="simple">
<li><p>Use <a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a> to setup arguments for a kernel launch.</p></li>
<li><p>The <a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a> et al. functions will make a copy of the kernel arguments to send to the device.</p></li>
<li><p>Kernel arguments can be updated at any time and used across multiple append calls.</p></li>
</ul>
<p>The following pseudo-code demonstrates a sequence for setting kernel arguments and launching the kernel:</p>
<pre class="literal-block">// Bind arguments
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 0, sizeof(ze_image_handle_t), &amp;src_image);
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 1, sizeof(ze_image_handle_t), &amp;dest_image);
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 2, sizeof(uint32_t), &amp;width);
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 3, sizeof(uint32_t), &amp;height);

<a class="reference internal" href="api.html#ze-group-count-t"><span class="std std-ref">ze_group_count_t</span></a> launchArgs = { numGroupsX, numGroupsY, 1 };

// Append launch kernel
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);

// Update image pointers to copy and scale next image.
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 0, sizeof(ze_image_handle_t), &amp;src2_image);
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 1, sizeof(ze_image_handle_t), &amp;dest2_image);

// Append launch kernel
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);

...</pre>
</div>
<div class="section" id="kernel-launch">
<h4>Kernel Launch<a class="headerlink" href="#kernel-launch" title="Permalink to this headline">¶</a></h4>
<p>In order to launch a kernel on the device an application must call one of the AppendLaunchKernel-style functions for
a command list. The most basic version of these is <a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a> which takes a
command list, kernel handle, launch arguments, and an optional synchronization event used to signal completion.
The launch arguments contain thread group dimensions.</p>
<pre class="literal-block">// compute number of groups to launch based on image size and group size.
uint32_t numGroupsX = imageWidth / groupSizeX;
uint32_t numGroupsY = imageHeight / groupSizeY;

<a class="reference internal" href="api.html#ze-group-count-t"><span class="std std-ref">ze_group_count_t</span></a> launchArgs = { numGroupsX, numGroupsY, 1 };

// Append launch kernel
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);</pre>
<p>The function <a class="reference internal" href="api.html#zecommandlistappendlaunchkernelindirect"><span class="std std-ref">zeCommandListAppendLaunchKernelIndirect</span></a> allows the launch parameters to be supplied indirectly in a
buffer that the device reads instead of the command itself. This allows for the previous operations on the
device to generate the parameters.</p>
<pre class="literal-block"><a class="reference internal" href="api.html#ze-group-count-t"><span class="std std-ref">ze_group_count_t</span></a>* pIndirectArgs;

...
<a class="reference internal" href="api.html#zedriverallocdevicemem"><span class="std std-ref">zeDriverAllocDeviceMem</span></a>(hDriver, &amp;desc, sizeof(<a class="reference internal" href="api.html#ze-group-count-t"><span class="std std-ref">ze_group_count_t</span></a>), sizeof(uint32_t), hDevice, &amp;pIndirectArgs);

// Append launch kernel - indirect
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernelindirect"><span class="std std-ref">zeCommandListAppendLaunchKernelIndirect</span></a>(hCommandList, hKernel, &amp;pIndirectArgs, nullptr, 0, nullptr);</pre>
</div>
<div class="section" id="cooperative-kernels">
<h4>Cooperative Kernels<a class="headerlink" href="#cooperative-kernels" title="Permalink to this headline">¶</a></h4>
<p>Cooperative kernels allow sharing of data and synchronization across all launched groups in a safe manner. To support this
there is a <a class="reference internal" href="api.html#zecommandlistappendlaunchcooperativekernel"><span class="std std-ref">zeCommandListAppendLaunchCooperativeKernel</span></a> that allows launching groups that can cooperate with each other.
The command list must be submitted to a logical command queue that was created with an ordinal of a physical command queue
that has the property <a class="reference internal" href="api.html#ze-command-queue-group-properties-t"><span class="std std-ref">ze_command_queue_group_properties_t</span></a>.cooperativeKernelsSupported equal true (1).
Finally, there is a <a class="reference internal" href="api.html#zekernelsuggestmaxcooperativegroupcount"><span class="std std-ref">zeKernelSuggestMaxCooperativeGroupCount</span></a> function that suggests a maximum group count size that
the device supports.</p>
</div>
</div>
<div class="section" id="sampler">
<h3>Sampler<a class="headerlink" href="#sampler" title="Permalink to this headline">¶</a></h3>
<p>The API supports Sampler objects that represent state needed for sampling images from within
kernels. The <a class="reference internal" href="api.html#zesamplercreate"><span class="std std-ref">zeSamplerCreate</span></a> function takes a sampler descriptor (<a class="reference internal" href="api.html#ze-sampler-desc-t"><span class="std std-ref">ze_sampler_desc_t</span></a>):</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 46%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Sampler Field</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Address Mode</p></td>
<td><p>Determines how out-of-bounds
accesses are handled. See
<a class="reference internal" href="api.html#ze-sampler-address-mode-t"><span class="std std-ref">ze_sampler_address_mode_t</span></a>.</p></td>
</tr>
<tr class="row-odd"><td><p>Filter Mode</p></td>
<td><p>Specifies which filtering mode to
use. See
<a class="reference internal" href="api.html#ze-sampler-filter-mode-t"><span class="std std-ref">ze_sampler_filter_mode_t</span></a>.</p></td>
</tr>
<tr class="row-even"><td><p>Normalized</p></td>
<td><p>Specifies whether coordinates for
addressing image are normalized
[0,1] or not.</p></td>
</tr>
</tbody>
</table>
<p>The following pseudo-code demonstrates the creation of a sampler object and passing it as a kernel argument:</p>
<pre class="literal-block">// Setup sampler for linear filtering and clamp out of bounds accesses to edge.
<a class="reference internal" href="api.html#ze-sampler-desc-t"><span class="std std-ref">ze_sampler_desc_t</span></a> desc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_SAMPLER_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-sampler-address-mode-t"><span class="std std-ref">ZE_SAMPLER_ADDRESS_MODE_CLAMP</span></a>,
    <a class="reference internal" href="api.html#ze-sampler-filter-mode-t"><span class="std std-ref">ZE_SAMPLER_FILTER_MODE_LINEAR</span></a>,
    false
    };
ze_sampler_handle_t sampler;
<a class="reference internal" href="api.html#zesamplercreate"><span class="std std-ref">zeSamplerCreate</span></a>(hDevice, &amp;desc, &amp;sampler);
...

// The sampler can be passed as a kernel argument.
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 0, sizeof(ze_sampler_handle_t), &amp;sampler);

// Append launch kernel
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);</pre>
</div>
</div>
<div class="section" id="advanced">
<h2>Advanced<a class="headerlink" href="#advanced" title="Permalink to this headline">¶</a></h2>
<div class="section" id="environment-variables">
<h3>Environment Variables<a class="headerlink" href="#environment-variables" title="Permalink to this headline">¶</a></h3>
<p>The following table documents the supported knobs for overriding default functional behavior.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 11%" />
<col style="width: 25%" />
<col style="width: 8%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Category</p></th>
<th class="head"><p>Name</p></th>
<th class="head"><p>Values</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td rowspan="2"><p>Device</p></td>
<td><p>ZE_AFFINITY_MASK</p></td>
<td><p>Hex String</p></td>
<td><p>Forces driver to only report devices (and sub-devices) as specified by mask value</p></td>
</tr>
<tr class="row-odd"><td><p>ZE_ENABLE_PCI_ID_DEVICE_ORDER</p></td>
<td><p>{<strong>0</strong>, 1}</p></td>
<td><p>Forces driver to report devices from lowest to highest PCI bus ID</p></td>
</tr>
<tr class="row-even"><td><p>Memory</p></td>
<td><p>ZE_SHARED_FORCE_DEVICE_ALLOC</p></td>
<td><p>{<strong>0</strong>, 1}</p></td>
<td><p>Forces all shared allocations into device memory</p></td>
</tr>
</tbody>
</table>
<div class="section" id="affinity-mask">
<h4>Affinity Mask<a class="headerlink" href="#affinity-mask" title="Permalink to this headline">¶</a></h4>
<p>The affinity mask allows an application or tool to restrict which devices, and sub-devices, are visible to 3rd-party libraries or applications in another process, respectively.
The affinity mask affects the number of handles returned from <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a> and <a class="reference internal" href="api.html#zedevicegetsubdevices"><span class="std std-ref">zeDeviceGetSubDevices</span></a>.
The affinity mask is specified via an environment variable as a string of hexadecimal values.
The value is specific to system configuration; e.g., the number of devices and the number of sub-devices for each device.
The value is specific to the order in which devices are reported by the driver; i.e., the first device maps to bit 0, the second device to bit 1, and so forth.</p>
<p>The order of the devices reported by the <a class="reference internal" href="api.html#zedeviceget"><span class="std std-ref">zeDeviceGet</span></a> can be forced to be consistent by setting the ZE_ENABLE_PCI_ID_DEVICE_ORDER environment variable.</p>
<p>The following examples demonstrate proper usage:</p>
<ul>
<li><p>“” (empty string) = disabled; i.e. all devices and sub-devices are reported. This is the default value.</p></li>
<li><p>Two devices, each with four sub-devices</p>
<blockquote>
<div><ul class="simple">
<li><p>“FF” = all devices and sub-devices are reported (same as default)</p></li>
<li><p>“0F” = only device 0 (with all its sub-devices) is reported</p></li>
<li><p>“F0” = only device 1 (with all its sub-devices) is reported as device 0’</p></li>
<li><p>“AA” = both device 0 and 1 are reported, however each only has two sub-devices reported as sub-device 0 and 1</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Two devices, device 0 with one sub-device and device 1 with two sub-devices</p>
<blockquote>
<div><ul class="simple">
<li><p>“07” = all devices and sub-devices are reported (same as default) + “01” = only device 0 (with all its sub-devices) is reported</p></li>
<li><p>“06” = only device 1 (with all its sub-devices) is reported as device 0</p></li>
<li><p>“05” = both device 0 and device 1 are reported, however each only has one sub-device reported as sub-device 0</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>
<div class="section" id="sub-device-support">
<h3>Sub-Device Support<a class="headerlink" href="#sub-device-support" title="Permalink to this headline">¶</a></h3>
<p>The API allows support for sub-devices which can enable finer grained
control of scheduling and memory allocation to a sub-partition of the device.
There are functions to query and obtain a sub-device, but outside of these
functions there are no distinctions between sub-devices and devices.</p>
<p>Use <a class="reference internal" href="api.html#zedevicegetsubdevices"><span class="std std-ref">zeDeviceGetSubDevices</span></a> to confirm sub-devices are supported and to
obtain a sub-device handle. There are additional device properties in
<a class="reference internal" href="api.html#ze-device-properties-t"><span class="std std-ref">ze_device_properties_t</span></a> for sub-devices to confirm a device is a
sub-device and to query the sub-device id. This is useful when needing
to pass a sub-device handle to another library.</p>
<p>When using a sub-device handle, device memory allocation will be placed
in the local memory that is attached to the sub-device. An out-of-memory error
indicates that there is not enough local sub-device memory for the
allocation. The driver will not try and spill sub-device allocations
over to another sub-device’s local memory. However, the application can
retry using the parent device and the driver will decide where to place
the allocation.</p>
<p>One thing to note is that the ordinal that is used when creating a
command queue is relative to the sub-device. This ordinal specifies
which physical compute queue on the device or sub-device to map the
logical queue to. The application needs to query
<a class="reference internal" href="api.html#ze-command-queue-group-properties-t"><span class="std std-ref">ze_command_queue_group_properties_t</span></a> from the sub-device to
determine how to set this ordinal. See <a class="reference internal" href="api.html#ze-command-queue-desc-t"><span class="std std-ref">ze_command_queue_desc_t</span></a> for
more details.</p>
<p>A 16-byte unique device identifier (uuid) can be obtained for a device
or sub-device using <a class="reference internal" href="api.html#zedevicegetproperties"><span class="std std-ref">zeDeviceGetProperties</span></a>.</p>
<pre class="literal-block">// Query for all sub-devices of the device
uint32_t subdeviceCount = 0;
<a class="reference internal" href="api.html#zedevicegetsubdevices"><span class="std std-ref">zeDeviceGetSubDevices</span></a>(hDevice, &amp;subdeviceCount, nullptr);

ze_device_handle_t* allSubDevices = allocate(subdeviceCount * sizeof(ze_device_handle_t));
<a class="reference internal" href="api.html#zedevicegetsubdevices"><span class="std std-ref">zeDeviceGetSubDevices</span></a>(hDevice, &amp;subdeviceCount, &amp;allSubDevices);

// Desire is to allocate and dispatch work to sub-device 2.
assert(subdeviceCount &gt;= 3);
ze_device_handle_t hSubdevice = allSubDevices[2];

// Query sub-device properties.
<a class="reference internal" href="api.html#ze-device-properties-t"><span class="std std-ref">ze_device_properties_t</span></a> subdeviceProps;
<a class="reference internal" href="api.html#zedevicegetproperties"><span class="std std-ref">zeDeviceGetProperties</span></a>(hSubdevice, &amp;subdeviceProps);

assert(subdeviceProps.isSubdevice == true); // Ensure that we have a handle to a sub-device.
assert(subdeviceProps.subdeviceId == 2);    // Ensure that we have a handle to the sub-device we asked for.

void* pMemForSubDevice2;
<a class="reference internal" href="api.html#zedriverallocdevicemem"><span class="std std-ref">zeDriverAllocDeviceMem</span></a>(hDriver, &amp;desc, memSize, sizeof(uint32_t), hSubdevice, &amp;pMemForSubDevice2);
...</pre>
</div>
<div class="section" id="device-residency">
<h3>Device Residency<a class="headerlink" href="#device-residency" title="Permalink to this headline">¶</a></h3>
<p>For devices that do not support page-faults, the driver must ensure that
all pages that will be accessed by the kernel are resident before
program execution. This can be determined by checking
<a class="reference internal" href="api.html#ze-device-properties-t"><span class="std std-ref">ze_device_properties_t</span></a>.onDemandPageFaultsSupported.</p>
<p>In most cases, the driver implicitly handles residency of allocations
for device access. This can be done by inspecting API parameters,
including kernel arguments. However, in cases where the devices does
<strong>not</strong> support page-faulting <em>and</em> the driver is incapable of
determining whether an allocation will be accessed by the device, such
as multiple levels of indirection, there are two methods available:</p>
<ol class="arabic">
<li><p>The application may set the <a class="reference internal" href="api.html#ze-kernel-flag-t"><span class="std std-ref">ZE_KERNEL_FLAG_FORCE_RESIDENCY</span></a> flag during program creation to force all device allocations to be resident during execution.</p>
<blockquote>
<div><ul>
<li><p>The application should specify which allocations will be indirectly accessed, using <a class="reference internal" href="api.html#zekernelsetattribute"><span class="std std-ref">zeKernelSetAttribute</span></a> and the following, to optimize which allocations are made resident.</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="api.html#ze-kernel-attribute-t"><span class="std std-ref">ZE_KERNEL_ATTRIBUTE_INDIRECT_HOST_ACCESS</span></a></p></li>
<li><p><a class="reference internal" href="api.html#ze-kernel-attribute-t"><span class="std std-ref">ZE_KERNEL_ATTRIBUTE_INDIRECT_DEVICE_ACCESS</span></a></p></li>
<li><p><a class="reference internal" href="api.html#ze-kernel-attribute-t"><span class="std std-ref">ZE_KERNEL_ATTRIBUTE_INDIRECT_SHARED_ACCESS</span></a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>If the driver is unable to make all allocations resident, then the call to <a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a> will return <a class="reference internal" href="api.html#ze-result-t"><span class="std std-ref">ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY</span></a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Explcit <a class="reference internal" href="api.html#zedevicemakememoryresident"><span class="std std-ref">zeDeviceMakeMemoryResident</span></a> APIs are included for the application to dynamically change residency as needed. (Windows-only)</p>
<blockquote>
<div><ul class="simple">
<li><p>If the application over-commits device memory, then a call to <a class="reference internal" href="api.html#zedevicemakememoryresident"><span class="std std-ref">zeDeviceMakeMemoryResident</span></a> will return <a class="reference internal" href="api.html#ze-result-t"><span class="std std-ref">ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY</span></a></p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p>If the application does not properly manage residency for these cases then the device may experience unrecoverable page-faults.</p>
<p>The following pseudo-code demonstrates a sequence for using coarse-grain residency control for indirect arguments:</p>
<pre class="literal-block">struct node {
    node* next;
};
node* begin = nullptr;
<a class="reference internal" href="api.html#zedriverallochostmem"><span class="std std-ref">zeDriverAllocHostMem</span></a>(hDriver, &amp;desc, sizeof(node), 1, &amp;begin);
<a class="reference internal" href="api.html#zedriverallochostmem"><span class="std std-ref">zeDriverAllocHostMem</span></a>(hDriver, &amp;desc, sizeof(node), 1, &amp;begin-&gt;next);
<a class="reference internal" href="api.html#zedriverallochostmem"><span class="std std-ref">zeDriverAllocHostMem</span></a>(hDriver, &amp;desc, sizeof(node), 1, &amp;begin-&gt;next-&gt;next);

// 'begin' is passed as kernel argument and appended into command list
bool hasIndirectHostAccess = true;
<a class="reference internal" href="api.html#zekernelsetattribute"><span class="std std-ref">zeKernelSetAttribute</span></a>(hFuncArgs, <a class="reference internal" href="api.html#ze-kernel-attribute-t"><span class="std std-ref">ZE_KERNEL_ATTRIBUTE_INDIRECT_HOST_ACCESS</span></a>, sizeof(bool), &amp;hasIndirectHostAccess);
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 0, sizeof(node*), &amp;begin);
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);

...

<a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a>(hCommandQueue, 1, &amp;hCommandList, nullptr);
...</pre>
<p>The following pseudo-code demonstrates a sequence for using fine-grain residency control for indirect arguments:</p>
<pre class="literal-block">struct node {
    node* next;
};
node* begin = nullptr;
<a class="reference internal" href="api.html#zedriverallochostmem"><span class="std std-ref">zeDriverAllocHostMem</span></a>(hDriver, &amp;desc, sizeof(node), 1, &amp;begin);
<a class="reference internal" href="api.html#zedriverallochostmem"><span class="std std-ref">zeDriverAllocHostMem</span></a>(hDriver, &amp;desc, sizeof(node), 1, &amp;begin-&gt;next);
<a class="reference internal" href="api.html#zedriverallochostmem"><span class="std std-ref">zeDriverAllocHostMem</span></a>(hDriver, &amp;desc, sizeof(node), 1, &amp;begin-&gt;next-&gt;next);

// 'begin' is passed as kernel argument and appended into command list
<a class="reference internal" href="api.html#zekernelsetargumentvalue"><span class="std std-ref">zeKernelSetArgumentValue</span></a>(hKernel, 0, sizeof(node*), &amp;begin);
<a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;launchArgs, nullptr, 0, nullptr);
...

// Make indirect allocations resident before enqueuing
<a class="reference internal" href="api.html#zedevicemakememoryresident"><span class="std std-ref">zeDeviceMakeMemoryResident</span></a>(hDevice, begin-&gt;next, sizeof(node));
<a class="reference internal" href="api.html#zedevicemakememoryresident"><span class="std std-ref">zeDeviceMakeMemoryResident</span></a>(hDevice, begin-&gt;next-&gt;next, sizeof(node));

<a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a>(hCommandQueue, 1, &amp;hCommandList, hFence);

// wait until complete
<a class="reference internal" href="api.html#zefencehostsynchronize"><span class="std std-ref">zeFenceHostSynchronize</span></a>(hFence, UINT32_MAX);

// Finally, evict to free device resources
<a class="reference internal" href="api.html#zedeviceevictmemory"><span class="std std-ref">zeDeviceEvictMemory</span></a>(hDevice, begin-&gt;next, sizeof(node));
<a class="reference internal" href="api.html#zedeviceevictmemory"><span class="std std-ref">zeDeviceEvictMemory</span></a>(hDevice, begin-&gt;next-&gt;next, sizeof(node));
...</pre>
</div>
<div class="section" id="opencl-interoperability">
<h3>OpenCL Interoperability<a class="headerlink" href="#opencl-interoperability" title="Permalink to this headline">¶</a></h3>
<p>Interoperability with OpenCL is currently only supported <em>from</em> OpenCL
<em>to</em> Level-Zero for a subset of types. The APIs are designed to be OS
agnostics and allow implementations to optimize for unified device
drivers; while allowing less optimal interoperability across different
device types and/or vendors.</p>
<p>There are three OpenCL types that can be shared for interoperability:</p>
<ol class="arabic simple">
<li><p><strong>cl_mem</strong> - an OpenCL buffer object</p></li>
<li><p><strong>cl_program</strong> - an OpenCL program object</p></li>
<li><p><strong>cl_command_queue</strong> - an OpenCL command queue object</p></li>
</ol>
<div class="section" id="cl-mem">
<h4>cl_mem<a class="headerlink" href="#cl-mem" title="Permalink to this headline">¶</a></h4>
<p>OpenCL buffer objects may be registered for use as a Level-Zero device
memory allocation. Registering an OpenCL buffer object with Level-Zero
merely obtains a pointer to the underlying device memory allocation and
does not alter the lifetime of the device memory underlying the OpenCL
buffer object. Freeing the Level-Zero device memory allocation
effectively “un-registers” the allocation from Level-Zero, and should be
performed before the OpenCL buffer object is destroyed. Using the
Level-Zero device memory allocation after destroying its associated
OpenCL buffer object will result in undefined behavior.</p>
<p>Applications are responsible for enforcing memory consistency for shared
buffer objects using existing OpenCL and/or Level-Zero APIs.</p>
</div>
<div class="section" id="cl-program">
<h4>cl_program<a class="headerlink" href="#cl-program" title="Permalink to this headline">¶</a></h4>
<p>Level-Zero modules are always in a compiled state and therefore prior to
retrieving an ze_module_handle_t from a cl_program the caller must
ensure the cl_program is compiled and linked.</p>
</div>
<div class="section" id="cl-command-queue">
<h4>cl_command_queue<a class="headerlink" href="#cl-command-queue" title="Permalink to this headline">¶</a></h4>
<p>Sharing OpenCL command queues provides opportunities to minimize
transition costs when submitting work from an OpenCL queue followed by
submitting work to Level-Zero command queue and vice-versa. Enqueuing
Level-Zero command lists to Level-Zero command queues are immediately
submitted to the device. OpenCL implementations, however, may not
necessarily submit tasks to the device unless forced by explicit OpenCL
API such as clFlush or clFinish. To minimize overhead between sharing
command queues, applications must explicitly submit OpenCL command
queues using clFlush, clFinish or similar operations prior to enqueuing
a Level-Zero command list. Failing to explicitly submit device work may
result in undefined behavior.</p>
<p>Sharing an OpenCL command queue doesn’t alter the lifetime of the API
object. It provides knowledge for the driver to potentially reuse some
internal resources which may have noticeable overhead when switching the
resources.</p>
<p>Memory contents as reflected by any caching schemes will be consistent
such that, for example, a memory write in an OpenCL command queue can be
read by a subsequent Level-Zero command list without any special
application action. The cost to ensure memory consistency may be
implementation dependent. The performance of sharing command queues will
be no worse than an application submitting work to OpenCL, calling
clFinish followed by submitting a Level-Zero command list. In most
cases, command queue sharing may be much more efficient.</p>
</div>
</div>
<div class="section" id="inter-process-communication">
<span id="id9"></span><h3>Inter-Process Communication<a class="headerlink" href="#inter-process-communication" title="Permalink to this headline">¶</a></h3>
<p>The API allows sharing of memory objects across different device
processes. Since each process has its own virtual address space, there
is no guarantee that the same virtual address will be available when the
memory object is shared in new process. There are a set of APIs that
makes it easier to share the memory objects with ease.</p>
<p>There are two types of Inter-Process Communication (IPC) APIs for using
Level-Zero allocations across processes:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#memory-1"><span class="std std-ref">Memory</span></a></p></li>
<li><p><a class="reference internal" href="#events-1"><span class="std std-ref">Events</span></a></p></li>
</ol>
<div class="section" id="memory-1">
<span id="id10"></span><h4>Memory<a class="headerlink" href="#memory-1" title="Permalink to this headline">¶</a></h4>
<p>The following code examples demonstrate how to use the memory IPC APIs:</p>
<ol class="arabic simple">
<li><p>First, the allocation is made, packaged, and sent on the sending
process:</p></li>
</ol>
<pre class="literal-block">void* dptr = nullptr;
<a class="reference internal" href="api.html#zedriverallocdevicemem"><span class="std std-ref">zeDriverAllocDeviceMem</span></a>(hDriver, &amp;desc, size, alignment, hDevice, &amp;dptr);

<a class="reference internal" href="api.html#ze-ipc-mem-handle-t"><span class="std std-ref">ze_ipc_mem_handle_t</span></a> hIPC;
<a class="reference internal" href="api.html#zedrivergetmemipchandle"><span class="std std-ref">zeDriverGetMemIpcHandle</span></a>(hDriver, dptr, &amp;hIPC);

// Method of sending to receiving process is not defined by Level-Zero:
send_to_receiving_process(hIPC);</pre>
<ol class="arabic simple" start="2">
<li><p>Next, the allocation is received and un-packaged on the receiving
process:</p></li>
</ol>
<pre class="literal-block">// Method of receiving from sending process is not defined by Level-Zero:
<a class="reference internal" href="api.html#ze-ipc-mem-handle-t"><span class="std std-ref">ze_ipc_mem_handle_t</span></a> hIPC;
hIPC = receive_from_sending_process();

void* dptr = nullptr;
<a class="reference internal" href="api.html#zedriveropenmemipchandle"><span class="std std-ref">zeDriverOpenMemIpcHandle</span></a>(hDriver, hDevice, hIPC, <a class="reference internal" href="api.html#ze-ipc-memory-flag-t"><span class="std std-ref">ZE_IPC_MEMORY_FLAG_NONE</span></a>, &amp;dptr);</pre>
<ol class="arabic simple" start="3">
<li><p>Each process may now refer to the same device memory allocation via its <code class="docutils literal notranslate"><span class="pre">dptr</span></code>.
Note, there is no guaranteed address equivalence for the values of <code class="docutils literal notranslate"><span class="pre">dptr</span></code> in each process.</p></li>
<li><p>To cleanup, first close the handle in the receiving process:</p></li>
</ol>
<pre class="literal-block"><a class="reference internal" href="api.html#zedriverclosememipchandle"><span class="std std-ref">zeDriverCloseMemIpcHandle</span></a>(hDriver, dptr);</pre>
<ol class="arabic simple" start="5">
<li><p>Finally, free the device pointer in the sending process:</p></li>
</ol>
<pre class="literal-block"><a class="reference internal" href="api.html#zedriverfreemem"><span class="std std-ref">zeDriverFreeMem</span></a>(hDriver, dptr);</pre>
</div>
<div class="section" id="events-1">
<span id="id11"></span><h4>Events<a class="headerlink" href="#events-1" title="Permalink to this headline">¶</a></h4>
<p>The following code examples demonstrate how to use the event IPC APIs:</p>
<ol class="arabic simple">
<li><p>First, the event pool is created, packaged, and sent on the sending process:</p></li>
</ol>
<pre class="literal-block">// create event pool
<a class="reference internal" href="api.html#ze-event-pool-desc-t"><span class="std std-ref">ze_event_pool_desc_t</span></a> eventPoolDesc = {
    <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_POOL_DESC</span></a>,
    nullptr,
    <a class="reference internal" href="api.html#ze-event-pool-flag-t"><span class="std std-ref">ZE_EVENT_POOL_FLAG_IPC</span></a> | <a class="reference internal" href="api.html#ze-event-pool-flag-t"><span class="std std-ref">ZE_EVENT_POOL_FLAG_HOST_VISIBLE</span></a>,
    10
};
ze_event_pool_handle_t hEventPool;
<a class="reference internal" href="api.html#zeeventpoolcreate"><span class="std std-ref">zeEventPoolCreate</span></a>(hDriver, &amp;eventPoolDesc, 1, &amp;hDevice, &amp;hEventPool);

// get IPC handle and send to another process
<a class="reference internal" href="api.html#ze-ipc-event-pool-handle-t"><span class="std std-ref">ze_ipc_event_pool_handle_t</span></a> hIpcEvent;
<a class="reference internal" href="api.html#zeeventpoolgetipchandle"><span class="std std-ref">zeEventPoolGetIpcHandle</span></a>(hEventPool, &amp;hIpcEventPool);
send_to_receiving_process(hIpcEventPool);</pre>
<ol class="arabic simple" start="2">
<li><p>Next, the event pool is received and un-packaged on the receiving process:</p></li>
</ol>
<pre class="literal-block">// get IPC handle from other process
<a class="reference internal" href="api.html#ze-ipc-event-pool-handle-t"><span class="std std-ref">ze_ipc_event_pool_handle_t</span></a> hIpcEventPool;
receive_from_sending_process(&amp;hIpcEventPool);

// open event pool
ze_event_pool_handle_t hEventPool;
<a class="reference internal" href="api.html#zeeventpoolopenipchandle"><span class="std std-ref">zeEventPoolOpenIpcHandle</span></a>(hDriver, hIpcEventPool, &amp;hEventPool);</pre>
<ol class="arabic simple" start="3">
<li><p>Each process may now refer to the same device event allocation via its handle:</p>
<ol class="loweralpha simple">
<li><p>Receiving process creates event at location</p></li>
</ol>
</li>
</ol>
<pre class="literal-block">    ze_event_handle_t hEvent;
    <a class="reference internal" href="api.html#ze-event-desc-t"><span class="std std-ref">ze_event_desc_t</span></a> eventDesc = {
        <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_DESC</span></a>,
        nullptr,
        5,
        <a class="reference internal" href="api.html#ze-event-scope-flag-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_NONE</span></a>,
        <a class="reference internal" href="api.html#ze-event-scope-flag-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_HOST</span></a>, // ensure memory coherency across device and Host after event signaled
    };
    <a class="reference internal" href="api.html#zeeventcreate"><span class="std std-ref">zeEventCreate</span></a>(hEventPool, &amp;eventDesc, &amp;hEvent);

    // submit kernel and signal event when complete
    <a class="reference internal" href="api.html#zecommandlistappendlaunchkernel"><span class="std std-ref">zeCommandListAppendLaunchKernel</span></a>(hCommandList, hKernel, &amp;args, hEvent, 0, nullptr);
    <a class="reference internal" href="api.html#zecommandlistclose"><span class="std std-ref">zeCommandListClose</span></a>(hCommandList);
    <a class="reference internal" href="api.html#zecommandqueueexecutecommandlists"><span class="std std-ref">zeCommandQueueExecuteCommandLists</span></a>(hCommandQueue, 1, &amp;hCommandList, nullptr);

b. Sending process creates event at same location</pre>
<pre class="literal-block">    ze_event_handle_t hEvent;
    <a class="reference internal" href="api.html#ze-event-desc-t"><span class="std std-ref">ze_event_desc_t</span></a> eventDesc = {
        <a class="reference internal" href="api.html#ze-structure-type-t"><span class="std std-ref">ZE_STRUCTURE_TYPE_EVENT_DESC</span></a>,
        nullptr,
        5,
        <a class="reference internal" href="api.html#ze-event-scope-flag-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_NONE</span></a>,
        <a class="reference internal" href="api.html#ze-event-scope-flag-t"><span class="std std-ref">ZE_EVENT_SCOPE_FLAG_HOST</span></a>, // ensure memory coherency across device and Host after event signaled
    };
    <a class="reference internal" href="api.html#zeeventcreate"><span class="std std-ref">zeEventCreate</span></a>(hEventPool, &amp;eventDesc, &amp;hEvent);

    <a class="reference internal" href="api.html#zeeventhostsynchronize"><span class="std std-ref">zeEventHostSynchronize</span></a>(hEvent, UINT32_MAX);

Note, there is no guaranteed address equivalence for the values of <code class="docutils literal notranslate"><span class="pre">hEvent</span></code> in each process.</pre>
<ol class="arabic simple" start="4">
<li><p>To cleanup, first close the pool handle in the receiving process:</p></li>
</ol>
<pre class="literal-block"><a class="reference internal" href="api.html#zeeventdestroy"><span class="std std-ref">zeEventDestroy</span></a>(hEvent);
<a class="reference internal" href="api.html#zeeventpoolcloseipchandle"><span class="std std-ref">zeEventPoolCloseIpcHandle</span></a>(&amp;hEventPool);</pre>
<ol class="arabic simple" start="5">
<li><p>Finally, free the event pool handle in the sending process:</p></li>
</ol>
<pre class="literal-block"><a class="reference internal" href="api.html#zeeventdestroy"><span class="std std-ref">zeEventDestroy</span></a>(hEvent);
<a class="reference internal" href="api.html#zeeventpooldestroy"><span class="std std-ref">zeEventPoolDestroy</span></a>(hEventPool);</pre>
</div>
</div>
<div class="section" id="peer-to-peer-access-and-queries">
<h3>Peer-to-Peer Access and Queries<a class="headerlink" href="#peer-to-peer-access-and-queries" title="Permalink to this headline">¶</a></h3>
<p>Peer to Peer API’s provide capabilities to marshall data across Host to
Device, Device to Host and Device to Device. The data marshalling API
can be scheduled as asynchronous operations or can be synchronized with
kernel execution through command queues. Data coherency is maintained by
the driver without any explicit involvement from the application.</p>
<p>Devices may be linked together within a node by a scale-up fabric and depending on the configuration,
the fabric can support atomics, compute kernel remote access, and data copies.</p>
<p>The following Peer-to-Peer functionalities are provided through the API:</p>
<ul>
<li><p>Check for existence of peer-to-peer fabric between two devices.</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="api.html#zedevicecanaccesspeer"><span class="std std-ref">zeDeviceCanAccessPeer</span></a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Query remote memory access and atomic capabilities for peer-to-peer</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="api.html#zedevicegetp2pproperties"><span class="std std-ref">zeDeviceGetP2PProperties</span></a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Copy data between devices over peer-to-peer fabric.</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="api.html#zecommandlistappendmemorycopy"><span class="std std-ref">zeCommandListAppendMemoryCopy</span></a></p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../tools/PROG.html" class="btn btn-neutral float-right" title="Tools Programming Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="INTRO.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Intel

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>