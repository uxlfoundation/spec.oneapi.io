

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Initialization &mdash; Level Zero Specification  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/custom.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Introduction" href="SYSMAN.html" />
    <link rel="prev" title="Core Programming Guide" href="../core/PROG.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Level Zero Specification
          

          
          </a>

          
            
            
              <div class="version">
                0.91
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../core/INTRO.html">Overview</a></li>
</ul>
<p class="caption"><span class="caption-text">Core Programming Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../core/PROG.html">Core Programming Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">Tools Programming Guide</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Initialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="#api-tracing">API Tracing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#registration">Registration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#enabling-disabling-and-destruction">Enabling/Disabling and Destruction</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#metrics">Metrics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction-1">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#metric-groups">Metric Groups</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sampling-types">Sampling Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#domains">Domains</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#enumeration">Enumeration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#configuration">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#collection">Collection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#metric-tracer">Metric Tracer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#metric-query">Metric Query</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#calculation">Calculation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#program-instrumentation">Program Instrumentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction-2">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inter-function-instrumentation">Inter-Function Instrumentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#intra-function-instrumentation">Intra-Function Instrumentation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#compilation">Compilation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#instrumentation">Instrumentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#execution">Execution</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#program-debug">Program Debug</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction-3">Introduction</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Sysman Programming Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="SYSMAN.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="SYSMAN.html#high-level-overview">High-level overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="SYSMAN.html#interface-details">Interface details</a></li>
<li class="toctree-l1"><a class="reference internal" href="SYSMAN.html#security">Security</a></li>
</ul>
<p class="caption"><span class="caption-text">SPIR-V Programming Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../core/SPIRV.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core/SPIRV.html#common-properties">Common Properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core/SPIRV.html#required-capabilities">Required Capabilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core/SPIRV.html#validation-rules">Validation Rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core/SPIRV.html#extensions">Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core/SPIRV.html#numerical-compliance">Numerical Compliance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../core/SPIRV.html#image-addressing-and-filtering">Image Addressing and Filtering</a></li>
</ul>
<p class="caption"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../core/api.html">Core API</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">Tools API</a></li>
</ul>
<p class="caption"><span class="caption-text">Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../versions.html">Latest Release</a></li>
<li class="toctree-l1"><a class="reference internal" href="../versions.html#previous-releases">Previous Releases</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Level Zero Specification</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    

    

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="initialization">
<h1>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">¶</a></h1>
<p>The driver must be initialized by calling ::zetInit after calling ::zeInit
and before calling any other experimental function. Simultaneous calls
to ::zetInit are thread-safe.</p>
</div>
<div class="section" id="api-tracing">
<span id="id1"></span><h1>API Tracing<a class="headerlink" href="#api-tracing" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>API tracing provides a way for tools to recieve notifications of API
calls made by an applicaton. The callbacks provide direct access to the
input and output parameters for viewing and modification. Tools may also
use these notifications as triggers to block and inject new API calls
into the command stream, such as metrics.</p>
</div>
<div class="section" id="registration">
<h2>Registration<a class="headerlink" href="#registration" title="Permalink to this headline">¶</a></h2>
<p>Tools may independently register for enter and exist callbacks for individual API calls, per driver instance.</p>
<ul class="simple">
<li><p>::zetTracerSetPrologues is used to specify all the enter callbacks</p></li>
<li><p>::zetTracerSetEpilogues is used to specify all the exist callbacks</p></li>
<li><p>If the value of a callback is nullptr, then it will be ignored.</p></li>
</ul>
<p>The callbacks are defined as a collection of per-API function pointers, with the following parameters:</p>
<ul class="simple">
<li><p>params : a structure capturing pointers to the input and output parameters of the current instance</p></li>
<li><p>result : the current value of the return value</p></li>
<li><p>pTracerUserData : the user’s pointer for the tracer’s data</p></li>
<li><p>ppTracerInstanceUserData : a per-tracer, per-instance storage location; typically used for passing data from the prologue to the epilogue</p></li>
</ul>
<p>Note: since the creation of a tracer requires a device, on first glance
it appears that ::zeInit, ::zeDriverGet and ::zeDeviceGet are not
traceable. However, these APIs <strong>are</strong> traceable for all calls
subsequent from the creation and enabling of the tracer itself.</p>
</div>
<div class="section" id="enabling-disabling-and-destruction">
<h2>Enabling/Disabling and Destruction<a class="headerlink" href="#enabling-disabling-and-destruction" title="Permalink to this headline">¶</a></h2>
<p>The tracer is created in a disabled state and must be explicitly enabled
by calling ::zetTracerSetEnabled. The implementation guaranteed that
prologues and epilogues will always be executed in pairs; i.e.</p>
<ul class="simple">
<li><p>if the prologue was called then the epilogue is guaranteed to be called, even if another thread disabled the tracer between execution</p></li>
<li><p>if the prologue was not called then the epilogue is guaranteed not to be called, even if another thread enabled the tracer between execution</p></li>
</ul>
<p>The tracer should be disabled by the application before the tracer is
destoryed. If multiple threads are in-flight, then it is still possbile
that callbacks will continue to execute even after the tracer is
disabled; specifically due to the pairing rules above. Due to the
complexity involved in ensuring no threads are still or will be
executing a callback even after its been disabled, the implementation
will stall and wait for any outstanding threads during ::zetTracerDestroy.</p>
<p>The following pseudo-code demonstrates a basic usage of API tracing:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_my_tracer_data_t</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">instance</span><span class="p">;</span>
<span class="p">}</span> <span class="n">my_tracer_data_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_my_instance_data_t</span>
<span class="p">{</span>
    <span class="kt">clock_t</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span> <span class="n">my_instance_data_t</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">OnEnterCommandListAppendLaunchKernel</span><span class="p">(</span>
    <span class="n">ze_command_list_append_launch_function_params_t</span><span class="o">*</span> <span class="n">params</span><span class="p">,</span>
    <span class="n">ze_result_t</span> <span class="n">result</span><span class="p">,</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">pTracerUserData</span><span class="p">,</span>
    <span class="kt">void</span><span class="o">**</span> <span class="n">ppTracerInstanceUserData</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">my_instance_data_t</span><span class="o">*</span> <span class="n">instance_data</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_instance_data_t</span><span class="p">)</span> <span class="p">);</span>
    <span class="o">*</span><span class="n">ppTracerInstanceUserData</span> <span class="o">=</span> <span class="n">instance_data</span><span class="p">;</span>

    <span class="n">instance_data</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">OnExitCommandListAppendLaunchKernel</span><span class="p">(</span>
    <span class="n">ze_command_list_append_launch_function_params_t</span><span class="o">*</span> <span class="n">params</span><span class="p">,</span>
    <span class="n">ze_result_t</span> <span class="n">result</span><span class="p">,</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">pTracerUserData</span><span class="p">,</span>
    <span class="kt">void</span><span class="o">**</span> <span class="n">ppTracerInstanceUserData</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">clock_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>

    <span class="n">my_tracer_data_t</span><span class="o">*</span> <span class="n">tracer_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">my_tracer_data_t</span><span class="o">*</span><span class="p">)</span><span class="n">pTracerUserData</span><span class="p">;</span>
    <span class="n">my_instance_data_t</span><span class="o">*</span> <span class="n">instance_data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">my_instance_data_t</span><span class="o">**</span><span class="p">)</span><span class="n">ppTracerInstanceUserData</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">time</span> <span class="o">=</span> <span class="mf">1000.f</span> <span class="o">*</span> <span class="p">(</span> <span class="n">end</span> <span class="o">-</span> <span class="n">instance_data</span><span class="o">-&gt;</span><span class="n">start</span> <span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;zeCommandListAppendLaunchKernel #%d takes %.4f ms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tracer_data</span><span class="o">-&gt;</span><span class="n">instance</span><span class="o">++</span><span class="p">,</span> <span class="n">time</span><span class="p">);</span>

    <span class="n">free</span><span class="p">(</span><span class="n">instance_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">TracingExample</span><span class="p">(</span> <span class="p">...</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">my_tracer_data_t</span> <span class="n">tracer_data</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">zet_tracer_desc_t</span> <span class="n">tracer_desc</span><span class="p">;</span>
    <span class="n">tracer_desc</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">ZET_TRACER_DESC_VERSION_CURRENT</span><span class="p">;</span>
    <span class="n">tracer_desc</span><span class="p">.</span><span class="n">pUserData</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tracer_data</span><span class="p">;</span>
    <span class="n">zet_tracer_handle_t</span> <span class="n">hTracer</span><span class="p">;</span>
    <span class="n">zetTracerCreate</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tracer_desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hTracer</span><span class="p">);</span>

    <span class="c1">// Set all callbacks</span>
    <span class="n">zet_core_callbacks_t</span> <span class="n">prologCbs</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">zet_core_callbacks_t</span> <span class="n">epilogCbs</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">prologCbs</span><span class="p">.</span><span class="n">CommandList</span><span class="p">.</span><span class="n">pfnAppendLaunchFunction</span> <span class="o">=</span> <span class="n">OnEnterCommandListAppendLaunchKernel</span><span class="p">;</span>
    <span class="n">epilogCbs</span><span class="p">.</span><span class="n">CommandList</span><span class="p">.</span><span class="n">pfnAppendLaunchFunction</span> <span class="o">=</span> <span class="n">OnExitCommandListAppendLaunchKernel</span><span class="p">;</span>

    <span class="n">zetTracerSetPrologues</span><span class="p">(</span><span class="n">hTracer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prologCbs</span><span class="p">);</span>
    <span class="n">zetTracerSetEpilogues</span><span class="p">(</span><span class="n">hTracer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epilogCbs</span><span class="p">);</span>

    <span class="n">zetTracerSetEnabled</span><span class="p">(</span><span class="n">hTracer</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

    <span class="n">zeCommandListAppendLaunchKernel</span><span class="p">(</span><span class="n">hCommandList</span><span class="p">,</span> <span class="n">hFunction</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">launchArgs</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
    <span class="n">zeCommandListAppendLaunchKernel</span><span class="p">(</span><span class="n">hCommandList</span><span class="p">,</span> <span class="n">hFunction</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">launchArgs</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>
    <span class="n">zeCommandListAppendLaunchKernel</span><span class="p">(</span><span class="n">hCommandList</span><span class="p">,</span> <span class="n">hFunction</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">launchArgs</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nullptr</span><span class="p">);</span>

    <span class="n">zetTracerSetEnabled</span><span class="p">(</span><span class="n">hTracer</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">zetTracerDestroy</span><span class="p">(</span><span class="n">hTracer</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="metrics">
<h1>Metrics<a class="headerlink" href="#metrics" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction-1">
<span id="id2"></span><h2>Introduction<a class="headerlink" href="#introduction-1" title="Permalink to this headline">¶</a></h2>
<p>Devices provide programmable infrastructure designed to support
performance debugging. The API described in this document provides
access to these device metrics.</p>
<div class="line-block">
<div class="line">The following diagram illustrates the relationship between the metric
objects described in this document.</div>
</div>
<img alt="../_images/tools_metric_hierarchy.png" src="../_images/tools_metric_hierarchy.png" />
<p>Most of the detailed metrics require the device to be properly
programmed before use. It is important to understand that the device
programming is in most cases global. This generally means that if a
software tool or an application is using the metrics then no other
application can reliably use the same device resources.</p>
<p>The use of some metrics may negatively impact the performance of the
device. The intention of this API is to support performance debug and it
is not advised to use it in regular execution.</p>
</div>
<div class="section" id="metric-groups">
<h2>Metric Groups<a class="headerlink" href="#metric-groups" title="Permalink to this headline">¶</a></h2>
<p>The device infrastucture consists of non-programmable, pre-defined set
of counters, and a programmable network of connections that work with a
separate set of counters as well as other types of counters. For sake of
simplicity, the smallest unit of configuration is a Metric Group. Metric
Groups are sets of metrics that provide certain perspective on
workload’s performance. The groups aggregate metrics, define device
programming and available collection methods. An application may choose
to collect data from a number of Metric Groups provided that they all
belong to different domains. <a class="reference internal" href="#domains">Domains</a> are used as a software
representation of independent device resources that can safely be used
concurrently.</p>
<div class="section" id="sampling-types">
<h3>Sampling Types<a class="headerlink" href="#sampling-types" title="Permalink to this headline">¶</a></h3>
<p>Sampling types are a software representation of device capabilities in
terms of reading metric values. Each Metric Group provides information
which sampling types it supports. There are separate sets of APIs
supporting each of the sampling types <a class="reference internal" href="#time-based">Time-based</a> and <a class="reference internal" href="#event-based">Event-based</a>.</p>
<p>All available sampling types are defined in ::zet_metric_group_sampling_type_t.</p>
<ul class="simple">
<li><p>Information about supported sampling types for a given Metric Group is provided in ::zet_metric_group_properties_t.samplingType.</p></li>
<li><p>It’s possible that a device provides multiple Metric Groups with the same names but different sampling types.</p></li>
<li><p>When enumerating, it’s important to choose a Metric Group which supports the desired sampling type.</p></li>
</ul>
</div>
<div class="section" id="domains">
<span id="id3"></span><h3>Domains<a class="headerlink" href="#domains" title="Permalink to this headline">¶</a></h3>
<p>Every Metric Group belongs to a given domain (::zet_metric_group_properties_t.domain).</p>
<ul class="simple">
<li><p>The Metric Group typically define a uniform device counter configuration used for measurements.</p></li>
<li><p>Each domain represents an exclusive resource used by the Metric Group.</p></li>
<li><p>It’s possible to simultaneously gather data for two different Metric Groups, only if they belong to a different domain i.e. Metric Groups that can be collected concurrently will have different domain values.</p></li>
</ul>
</div>
</div>
<div class="section" id="enumeration">
<h2>Enumeration<a class="headerlink" href="#enumeration" title="Permalink to this headline">¶</a></h2>
<p>All available metrics are organized into Metric Groups.</p>
<ul class="simple">
<li><p>During data collection, data for the whole Metric Group is gathered.</p></li>
<li><p>The list of available Metric Groups and their Metrics is device-specific.</p></li>
</ul>
<p>The following APIs provide all the information needed for identification and usage.</p>
<ul class="simple">
<li><p>Metric Group properties are accessed through function ::zetMetricGroupGetProperties, returning ::zet_metric_group_properties_t.</p></li>
<li><p>Metric properties are accessed through function ::zetMetricGetProperties, returning ::zet_metric_properties_t.</p></li>
</ul>
<p>A common tool flow is to enumerate metrics looking for a specific Metric
Group. Depending on the metrics required for a specific scenario a tool
may choose to run the workload multiple times, recording different set
of Metric Groups each time. Usually care must be taken to ensure
run-to-run stability and result repeatability if metrics from different
runs are meant to be used together. When enumerating Metric tree to find
a desired Metric Group, it’s important to know in advance which sampling
type it will be used.</p>
<p>To enumerate through the Metric tree:</p>
<ol class="arabic">
<li><p>Call ::zetMetricGroupGet to obtain Metric Group count.</p></li>
<li><p>Call ::zetMetricGroupGet to obtain all Metric Groups.</p></li>
<li><p>Iterate over all available Metric Groups.</p>
<blockquote>
<div><ul class="simple">
<li><p>At this point it’s possible to check e.g. Metric Group name, domain or sampling type.</p></li>
<li><p>Metric Group names may not be unique.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>For each Metric Group obtain their Metric count calling ::zetMetricGroupGetProperties with Metric Group handle (::zet_metric_group_handle_t) and checking zet_metric_group_properties_t.metricCount.</p></li>
<li><p>Iterate over available Metrics using ::zetMetricGet with parent Metric Group (::zet_metric_group_handle_t).</p></li>
<li><p>Check Metric properties (e.g. name, description) calling ::zetMetricGetProperties with parent Metric (::zet_metric_handle_t).</p></li>
</ol>
<p>The following pseudo-code demonstrates a basic enumeration over all
available metric groups and their metrics. Additionally, it returns a
metric group with a chosen name and sampling type. Similar code could be
used for selecting a preferred metric group for a specific type of
measurements.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ze_result_t</span> <span class="nf">FindMetricGroup</span><span class="p">(</span> <span class="n">ze_device_handle_t</span> <span class="n">hDevice</span><span class="p">,</span>
                               <span class="kt">char</span><span class="o">*</span> <span class="n">pMetricGroupName</span><span class="p">,</span>
                               <span class="kt">uint32_t</span> <span class="n">desiredSamplingType</span><span class="p">,</span>
                               <span class="n">zet_metric_group_handle_t</span><span class="o">*</span> <span class="n">phMetricGroup</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Obtain available metric groups for the specific device</span>
    <span class="kt">uint32_t</span> <span class="n">metricGroupCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">zetMetricGroupGet</span><span class="p">(</span> <span class="n">hDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">metricGroupCount</span><span class="p">,</span> <span class="n">nullptr</span> <span class="p">);</span>

    <span class="n">zet_metric_group_handle_t</span><span class="o">*</span> <span class="n">phMetricGroups</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">metricGroupCount</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zet_metric_group_handle_t</span><span class="p">));</span>
    <span class="n">zetMetricGroupGet</span><span class="p">(</span> <span class="n">hDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">metricGroupCount</span><span class="p">,</span> <span class="n">phMetricGroups</span> <span class="p">);</span>

    <span class="c1">// Iterate over all metric groups available</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">metricGroupCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Get metric group under index &#39;i&#39; and its properties</span>
        <span class="n">zet_metric_group_properties_t</span> <span class="n">metricGroupProperties</span><span class="p">;</span>
        <span class="n">zetMetricGroupGetProperties</span><span class="p">(</span> <span class="n">phMetricGroups</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">metricGroupProperties</span> <span class="p">);</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Metric Group: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">metricGroupProperties</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

        <span class="c1">// Check whether the obtained metric group supports the desired sampling type</span>
        <span class="k">if</span><span class="p">((</span><span class="n">metricGroupProperties</span><span class="p">.</span><span class="n">samplingType</span> <span class="o">&amp;</span> <span class="n">desiredSamplingType</span><span class="p">)</span> <span class="o">==</span> <span class="n">desiredSamplingType</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Check whether the obtained metric group has the desired name</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">strcmp</span><span class="p">(</span> <span class="n">pMetricGroupName</span><span class="p">,</span> <span class="n">metricGroupProperties</span><span class="p">.</span><span class="n">name</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="o">*</span><span class="n">phMetricGroup</span> <span class="o">=</span> <span class="n">phMetricGroups</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">free</span><span class="p">(</span><span class="n">phMetricGroups</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="configuration">
<h2>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h2>
<p>Use the ::zetDeviceActivateMetricGroups API call to configure the device
for data collection.</p>
<ul class="simple">
<li><p>Subsequent calls to the function will disable device programming for the metric groups not selected for activation.</p></li>
<li><p>To avoid undefined results only call the ::zetDeviceActivateMetricGroups between experiments i.e. while not collecting data.</p></li>
</ul>
<p>Programming restrictions:</p>
<ul class="simple">
<li><p>Any combination of metric groups can be configured simultaneously provided that all of them have different ::zet_metric_group_properties_t.domain.</p></li>
<li><p>MetricGroup must be active until ::zetMetricQueryGetData and ::zetMetricTracerClose.</p></li>
<li><p>Conflicting Groups cannot be activated, in such case the call to ::zetDeviceActivateMetricGroups would fail.</p></li>
</ul>
</div>
<div class="section" id="collection">
<h2>Collection<a class="headerlink" href="#collection" title="Permalink to this headline">¶</a></h2>
<p>There are two modes of metrics collection supported: time-based and event-based.</p>
<ul class="simple">
<li><p>Time-based collection is using a timer as well as other events to store data samples. A metric tracer interface is the software interface for configuration and collection.</p></li>
<li><p>Event-based metrics collection is based on a pair of Begin/End events appended to command lists. A metric query interface is the software interface for configuration and collection.</p></li>
</ul>
<div class="section" id="metric-tracer">
<span id="time-based"></span><h3>Metric Tracer<a class="headerlink" href="#metric-tracer" title="Permalink to this headline">¶</a></h3>
<p>Time-based collection uses a simple Open, Wait, Read, Close scheme:
- ::zetMetricTracerOpen opens the tracer.
- ::zeEventHostSynchronize and ::zeEventQueryStatus can be used to wait for data.
- ::zetMetricTracerReadData reads the data to be later processed by ::zetMetricGroupCalculateMetricValues.
- ::zetMetricTracerClose closes the tracer.</p>
<img alt="../_images/tools_metric_tracer.png" src="../_images/tools_metric_tracer.png" />
<p>The following pseudo-code demonstrates a basic sequence for tracer-based collection:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ze_result_t</span> <span class="nf">TimeBasedUsageExample</span><span class="p">(</span> <span class="n">ze_driver_handle_t</span> <span class="n">hDriver</span><span class="p">,</span>
                                     <span class="n">ze_device_handle_t</span> <span class="n">hDevice</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">zet_metric_group_handle_t</span>     <span class="n">hMetricGroup</span>           <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="n">ze_event_handle_t</span>            <span class="n">hNotificationEvent</span>     <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="n">ze_event_pool_handle_t</span>       <span class="n">hEventPool</span>             <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="n">ze_event_pool_desc_t</span>         <span class="n">eventPoolDesc</span>          <span class="o">=</span> <span class="p">{</span><span class="n">ZE_EVENT_POOL_DESC_VERSION_CURRENT</span><span class="p">,</span> <span class="n">ZE_EVENT_POOL_FLAG_DEFAULT</span> <span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">ze_event_desc_t</span>              <span class="n">eventDesc</span>              <span class="o">=</span> <span class="p">{</span><span class="n">ZE_EVENT_DESC_VERSION_CURRENT</span><span class="p">};</span>
    <span class="n">zet_metric_tracer_handle_t</span>    <span class="n">hMetricTracer</span>          <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="n">zet_metric_tracer_desc_t</span>      <span class="n">metricTracerDescriptor</span> <span class="o">=</span> <span class="p">{</span><span class="n">ZET_METRIC_TRACER_DESC_VERSION_CURRENT</span><span class="p">};</span>

    <span class="c1">// Find a &quot;ComputeBasic&quot; metric group suitable for Time Based collection</span>
    <span class="n">FindMetricGroup</span><span class="p">(</span> <span class="n">hDevice</span><span class="p">,</span> <span class="s">&quot;ComputeBasic&quot;</span><span class="p">,</span> <span class="n">ZET_METRIC_GROUP_SAMPLING_TYPE_TIME_BASED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hMetricGroup</span> <span class="p">);</span>

    <span class="c1">// Configure the HW</span>
    <span class="n">zetDeviceActivateMetricGroups</span><span class="p">(</span> <span class="n">hDevice</span><span class="p">,</span> <span class="mi">1</span> <span class="cm">/* count */</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hMetricGroup</span> <span class="p">);</span>

    <span class="c1">// Create notification event</span>
    <span class="n">zeEventPoolCreate</span><span class="p">(</span> <span class="n">hDriver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventPoolDesc</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hEventPool</span> <span class="p">);</span>
    <span class="n">eventDesc</span><span class="p">.</span><span class="n">index</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">eventDesc</span><span class="p">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">XE_EVENT_SCOPE_FLAG_HOST</span><span class="p">;</span>
    <span class="n">eventDesc</span><span class="p">.</span><span class="n">wait</span>   <span class="o">=</span> <span class="n">XE_EVENT_SCOPE_FLAG_HOST</span><span class="p">;</span>
    <span class="n">zeEventCreate</span><span class="p">(</span> <span class="n">hEventPool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventDesc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hNotificationEvent</span> <span class="p">);</span>

    <span class="c1">// Open metric tracer</span>
    <span class="n">metricTracerDescriptor</span><span class="p">.</span><span class="n">samplingPeriod</span>       <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="n">metricTracerDescriptor</span><span class="p">.</span><span class="n">notifyEveryNReports</span>  <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span>
    <span class="n">zetMetricTracerOpen</span><span class="p">(</span> <span class="n">hDevice</span><span class="p">,</span> <span class="n">hMetricGroup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">metricTracerDescriptor</span><span class="p">,</span> <span class="n">hNotificationEvent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hMetricTracer</span> <span class="p">);</span>

    <span class="c1">// Run your workload, in this example we assume the data for the whole experiment fits in the device buffer</span>
    <span class="n">Workload</span><span class="p">(</span><span class="n">hDevice</span><span class="p">);</span>
    <span class="c1">// Optionally insert markers during workload execution</span>
    <span class="c1">//zetCommandListAppendMetricTracerMarker( hCommandList, hMetricTracer, tool_marker_value );</span>

    <span class="c1">// Wait for data, optional in this example since the whole workload has already been executed by now</span>
    <span class="c1">//zeEventHostSynchronize( hNotificationEvent, 1000 /*timeout*/ );</span>
    <span class="c1">// reset the event if it fired</span>

    <span class="c1">// Read raw data</span>
    <span class="kt">size_t</span> <span class="n">rawSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">zetMetricTracerReadData</span><span class="p">(</span> <span class="n">hMetricTracer</span><span class="p">,</span> <span class="n">UINT32_MAX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rawSize</span><span class="p">,</span> <span class="n">nullptr</span> <span class="p">);</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">rawData</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">rawSize</span><span class="p">);</span>
    <span class="n">zetMetricTracerReadData</span><span class="p">(</span> <span class="n">hMetricTracer</span><span class="p">,</span> <span class="n">UINT32_MAX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rawSize</span><span class="p">,</span> <span class="n">rawData</span> <span class="p">);</span>

    <span class="c1">// Close metric tracer</span>
    <span class="n">zetMetricTracerClose</span><span class="p">(</span> <span class="n">hMetricTracer</span> <span class="p">);</span>
    <span class="n">zeEventDestroy</span><span class="p">(</span> <span class="n">hNotificationEvent</span> <span class="p">);</span>
    <span class="n">zeEventPoolDestroy</span><span class="p">(</span> <span class="n">hEventPool</span> <span class="p">);</span>

    <span class="c1">// Deconfigure the device</span>
    <span class="n">zetDeviceActivateMetricGroups</span><span class="p">(</span> <span class="n">hDevice</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nullptr</span> <span class="p">);</span>

    <span class="c1">// Calculate metric data</span>
    <span class="n">CalculateMetricsExample</span><span class="p">(</span> <span class="n">hMetricGroup</span><span class="p">,</span> <span class="n">rawSize</span><span class="p">,</span> <span class="n">rawData</span> <span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">rawData</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="metric-query">
<span id="event-based"></span><h3>Metric Query<a class="headerlink" href="#metric-query" title="Permalink to this headline">¶</a></h3>
<p>Event-based collection uses a simple Begin, End, GetData scheme:</p>
<ul class="simple">
<li><p>::zetCommandListAppendMetricQueryBegin defines the start counting event</p></li>
<li><p>::zetCommandListAppendMetricQueryEnd defines the finish counting event</p></li>
<li><p>::zetMetricQueryGetData reads the raw data to be later processed by ::zetMetricGroupCalculateMetricValues.</p></li>
</ul>
<p>Typically, multiple queries are used and recycled to characterize a workload. A Query Pool is used to efficiently use and reuse device memory for multiple queries.</p>
<ul class="simple">
<li><p>::zetMetricQueryPoolCreate creates a pool of homogeneous queries.</p></li>
<li><p>::zetMetricQueryPoolDestroy frees the pool. The application must ensure no queries within the pool are in-use before freeing the pool.</p></li>
<li><p>::zetMetricQueryCreate obtains a handle to a unique location in the pool.</p></li>
<li><p>::zetMetricQueryReset allows for low-cost recycling of a location in the pool.</p></li>
</ul>
<img alt="../_images/tools_metric_query.png" src="../_images/tools_metric_query.png" />
<p>The following pseudo-code demonstrates a basic sequence for query-based collection:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ze_result_t</span> <span class="nf">MetricQueryUsageExample</span><span class="p">(</span> <span class="n">ze_driver_handle_t</span> <span class="n">hDriver</span><span class="p">,</span>
                                       <span class="n">ze_device_handle_t</span> <span class="n">hDevice</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">zet_metric_group_handle_t</span>      <span class="n">hMetricGroup</span>          <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="n">ze_event_handle_t</span>             <span class="n">hCompletionEvent</span>      <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="n">ze_event_pool_desc_t</span>          <span class="n">eventPoolDesc</span>         <span class="o">=</span> <span class="p">{</span><span class="n">ZE_EVENT_POOL_DESC_VERSION_CURRENT</span><span class="p">};</span>
    <span class="n">ze_event_desc_t</span>               <span class="n">eventDesc</span>             <span class="o">=</span> <span class="p">{</span><span class="n">ZE_EVENT_DESC_VERSION_CURRENT</span><span class="p">};</span>
    <span class="n">ze_event_pool_handle_t</span>        <span class="n">hEventPool</span>            <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="n">zet_metric_query_pool_handle_t</span> <span class="n">hMetricQueryPool</span>      <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="n">zet_metric_query_handle_t</span>      <span class="n">hMetricQuery</span>          <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="n">zet_metric_query_pool_desc_t</span>   <span class="n">queryPoolDesc</span>         <span class="o">=</span> <span class="p">{</span><span class="n">ZET_METRIC_QUERY_POOL_DESC_VERSION_CURRENT</span><span class="p">};</span>

    <span class="c1">// Find a &quot;ComputeBasic&quot; metric group suitable for Event Based collection</span>
    <span class="n">FindMetricGroup</span><span class="p">(</span> <span class="n">hDevice</span><span class="p">,</span> <span class="s">&quot;ComputeBasic&quot;</span><span class="p">,</span> <span class="n">ZET_METRIC_GROUP_SAMPLING_TYPE_EVENT_BASED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hMetricGroup</span> <span class="p">);</span>

    <span class="c1">// Configure HW</span>
    <span class="n">zetDeviceActivateMetricGroups</span><span class="p">(</span> <span class="n">hDevice</span><span class="p">,</span> <span class="mi">1</span> <span class="cm">/* count */</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hMetricGroup</span> <span class="p">);</span>

    <span class="c1">// Create metric query pool &amp; completion event</span>
    <span class="n">queryPoolDesc</span><span class="p">.</span><span class="n">flags</span>        <span class="o">=</span> <span class="n">ZET_METRIC_QUERY_POOL_FLAG_PERFORMANCE</span><span class="p">;</span>
    <span class="n">queryPoolDesc</span><span class="p">.</span><span class="n">count</span>        <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="n">zetMetricQueryPoolCreate</span><span class="p">(</span> <span class="n">hDevice</span><span class="p">,</span> <span class="n">hMetricGroup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queryPoolDesc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hMetricQueryPool</span> <span class="p">);</span>
    <span class="n">eventPoolDesc</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ZE_EVENT_POOL_FLAG_DEFAULT</span><span class="p">;</span>
    <span class="n">eventPoolDesc</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="n">zeEventPoolCreate</span><span class="p">(</span> <span class="n">hDriver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventPoolDesc</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hDevice</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hEventPool</span> <span class="p">);</span>

    <span class="c1">// Write BEGIN metric query to command list</span>
    <span class="n">zetMetricQueryCreate</span><span class="p">(</span> <span class="n">hMetricQueryPool</span><span class="p">,</span> <span class="mi">0</span> <span class="cm">/*slot*/</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hMetricQuery</span> <span class="p">);</span>
    <span class="n">zetCommandListAppendMetricQueryBegin</span><span class="p">(</span> <span class="n">hCommandList</span><span class="p">,</span> <span class="n">hMetricQuery</span> <span class="p">);</span>

    <span class="c1">// build your command list</span>

    <span class="c1">// Write END metric query to command list, use an event to determine if the data is available</span>
    <span class="n">eventDesc</span><span class="p">.</span><span class="n">index</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">eventDesc</span><span class="p">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">XE_EVENT_SCOPE_FLAG_HOST</span><span class="p">;</span>
    <span class="n">eventDesc</span><span class="p">.</span><span class="n">wait</span>   <span class="o">=</span> <span class="n">XE_EVENT_SCOPE_FLAG_HOST</span><span class="p">;</span>
    <span class="n">zeEventCreate</span><span class="p">(</span> <span class="n">hEventPool</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventDesc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hCompletionEvent</span><span class="p">);</span>
    <span class="n">zetCommandListAppendMetricQueryEnd</span><span class="p">(</span> <span class="n">hCommandList</span><span class="p">,</span> <span class="n">hMetricQuery</span><span class="p">,</span> <span class="n">hCompletionEvent</span> <span class="p">);</span>

    <span class="c1">// use zeCommandQueueExecuteCommandLists( , , , ) to submit your workload to the device</span>

    <span class="c1">// Wait for data</span>
    <span class="n">zeEventHostSynchronize</span><span class="p">(</span> <span class="n">hCompletionEvent</span><span class="p">,</span> <span class="mi">1000</span> <span class="cm">/*timeout*/</span> <span class="p">);</span>

    <span class="c1">// Read raw data</span>
    <span class="kt">size_t</span> <span class="n">rawSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">zetMetricQueryGetData</span><span class="p">(</span> <span class="n">hMetricQuery</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rawSize</span><span class="p">,</span> <span class="n">nullptr</span> <span class="p">);</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">rawData</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">rawSize</span><span class="p">);</span>
    <span class="n">zetMetricQueryGetData</span><span class="p">(</span> <span class="n">hMetricQuery</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rawSize</span><span class="p">,</span> <span class="n">rawData</span> <span class="p">);</span>

    <span class="c1">// Free the resources</span>
    <span class="n">zeEventDestroy</span><span class="p">(</span> <span class="n">hCompletionEvent</span> <span class="p">);</span>
    <span class="n">zeEventPoolDestroy</span><span class="p">(</span> <span class="n">hEventPool</span> <span class="p">);</span>
    <span class="n">zetMetricQueryPoolDestroy</span><span class="p">(</span> <span class="n">hMetricQueryPool</span> <span class="p">);</span>

    <span class="c1">// Deconfigure HW</span>
    <span class="n">zetDeviceActivateMetricGroups</span><span class="p">(</span> <span class="n">hDevice</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nullptr</span> <span class="p">);</span>

    <span class="c1">// Calculate metric data</span>
    <span class="n">CalculateMetricsExample</span><span class="p">(</span> <span class="n">hMetricGroup</span><span class="p">,</span> <span class="n">rawSize</span><span class="p">,</span> <span class="n">rawData</span> <span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">rawData</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="calculation">
<h2>Calculation<a class="headerlink" href="#calculation" title="Permalink to this headline">¶</a></h2>
<p>Both MetricTracer and MetricQueryPool collect the data in device specific, raw form that is not suitable for application processing. To calculate metric values use ::zetMetricGroupCalculateMetricValues.</p>
<p>The following pseudo-code demonstrates a basic sequence for metric calculation and interpretation:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ze_result_t</span> <span class="nf">CalculateMetricsExample</span><span class="p">(</span> <span class="n">zet_metric_group_handle_t</span> <span class="n">hMetricGroup</span><span class="p">,</span>
                                       <span class="kt">size_t</span> <span class="n">rawSize</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">rawData</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Calculate metric data</span>
    <span class="kt">uint32_t</span> <span class="n">numMetricValues</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">zetMetricGroupCalculateMetricValues</span><span class="p">(</span> <span class="n">hMetricGroup</span><span class="p">,</span> <span class="n">rawSize</span><span class="p">,</span> <span class="n">rawData</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numMetricValues</span><span class="p">,</span> <span class="n">nullptr</span> <span class="p">);</span>
    <span class="n">zet_typed_value_t</span><span class="o">*</span> <span class="n">metricValues</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span> <span class="n">numMetricValues</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zet_typed_value_t</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">zetMetricGroupCalculateMetricValues</span><span class="p">(</span> <span class="n">hMetricGroup</span><span class="p">,</span> <span class="n">rawSize</span><span class="p">,</span> <span class="n">rawData</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">numMetricValues</span><span class="p">,</span> <span class="n">metricValues</span> <span class="p">);</span>

    <span class="c1">// Obtain available metrics for the specific metric group</span>
    <span class="kt">uint32_t</span> <span class="n">metricCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">zetMetricGet</span><span class="p">(</span> <span class="n">hMetricGroup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">metricCount</span><span class="p">,</span> <span class="n">nullptr</span> <span class="p">);</span>

    <span class="n">zet_metric_handle_t</span><span class="o">*</span> <span class="n">phMetrics</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">metricCount</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zet_metric_handle_t</span><span class="p">));</span>
    <span class="n">zetMetricGet</span><span class="p">(</span> <span class="n">hMetricGroup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">metricCount</span><span class="p">,</span> <span class="n">phMetrics</span> <span class="p">);</span>

    <span class="c1">// Print metric results</span>
    <span class="kt">uint32_t</span> <span class="n">numReports</span> <span class="o">=</span> <span class="n">numMetricValues</span> <span class="o">/</span> <span class="n">metricCount</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">uint32_t</span> <span class="n">report</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">report</span> <span class="o">&lt;</span> <span class="n">numReports</span><span class="p">;</span> <span class="o">++</span><span class="n">report</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Report: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">report</span><span class="p">);</span>

        <span class="k">for</span><span class="p">(</span> <span class="kt">uint32_t</span> <span class="n">metric</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">metric</span> <span class="o">&lt;</span> <span class="n">metricCount</span><span class="p">;</span> <span class="o">++</span><span class="n">metric</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">zet_typed_value_t</span> <span class="n">data</span> <span class="o">=</span> <span class="n">metricValues</span><span class="p">[</span><span class="n">report</span> <span class="o">*</span> <span class="n">metricCount</span> <span class="o">+</span> <span class="n">metric</span><span class="p">];</span>

            <span class="n">zet_metric_properties_t</span> <span class="n">metricProperties</span><span class="p">;</span>
            <span class="n">zetMetricGetProperties</span><span class="p">(</span> <span class="n">phMetrics</span><span class="p">[</span> <span class="n">metric</span> <span class="p">],</span> <span class="o">&amp;</span><span class="n">metricProperties</span> <span class="p">);</span>

            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Metric: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">metricProperties</span><span class="p">.</span><span class="n">name</span> <span class="p">);</span>

            <span class="k">switch</span><span class="p">(</span> <span class="n">data</span><span class="p">.</span><span class="n">type</span> <span class="p">)</span>
            <span class="p">{</span>
            <span class="k">case</span> <span class="nl">ZET_VALUE_TYPE_UINT32</span><span class="p">:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot; Value: %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">ui32</span> <span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">ZET_VALUE_TYPE_UINT64</span><span class="p">:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot; Value: %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">ui64</span> <span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">ZET_VALUE_TYPE_FLOAT32</span><span class="p">:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot; Value: %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">fp32</span> <span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">ZET_VALUE_TYPE_FLOAT64</span><span class="p">:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot; Value: %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">fp64</span> <span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">ZET_VALUE_TYPE_BOOL8</span><span class="p">:</span>
                <span class="k">if</span><span class="p">(</span> <span class="n">data</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">ui32</span> <span class="p">)</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">&quot; Value: true</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
                <span class="k">else</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">&quot; Value: false</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">free</span><span class="p">(</span><span class="n">metricValues</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">phMetrics</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="program-instrumentation">
<h1>Program Instrumentation<a class="headerlink" href="#program-instrumentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction-2">
<span id="id4"></span><h2>Introduction<a class="headerlink" href="#introduction-2" title="Permalink to this headline">¶</a></h2>
<p>The program instrumentation APIs provide tools a basic framework for
low-level profiling of device programs, by allowing direct
instrumentation of those programs. These capabilities, in combination
with those already provided, in combination with API tracing, are
sufficient for more advanced frameworks to be developed independently.</p>
<p>There are two type of instrumentation available:</p>
<ol class="arabic simple">
<li><p>Inter-Function Instrumentation - intercepting and redirecting function calls</p></li>
<li><p>Intra-Function Instrumentation - injecting new instructions within a function</p></li>
</ol>
</div>
<div class="section" id="inter-function-instrumentation">
<h2>Inter-Function Instrumentation<a class="headerlink" href="#inter-function-instrumentation" title="Permalink to this headline">¶</a></h2>
<p>The following capabilities allow for a tool to intercept and redirect
function calls:</p>
<ul class="simple">
<li><p>Inter-module function calls - the ability to call functions between different modules; e.g., the application’s module and a tool’s module</p></li>
<li><p><a class="reference internal" href="#api-tracing">API-Tracing</a></p></li>
</ul>
<p>For example, a tool may use API Tracing in any of the following ways:</p>
<ul class="simple">
<li><p>::zeModuleCreate - replace a module handle with instrumented module handle for all functions</p></li>
<li><p>::zeKernelCreate - replace a kernel handle with instrumented kernel handle for all call sites</p></li>
<li><p>::zeModuleGetFunctionPointer - replace a function pointer with instrumented function pointer for all call sites</p></li>
<li><p>::zeCommandListAppendLaunchKernel - replace a kernel handle with instrumented kernel handle at call site</p></li>
</ul>
</div>
<div class="section" id="intra-function-instrumentation">
<h2>Intra-Function Instrumentation<a class="headerlink" href="#intra-function-instrumentation" title="Permalink to this headline">¶</a></h2>
<p>The following capabilities allow for a tool to inject instructions within a kernel:</p>
<ul class="simple">
<li><p>::zetModuleGetDebugInfo - allows a tool to query standard debug info for an application’s module</p></li>
<li><p>::zetKernelGetProfileInfo - allows a tool query detailed information on aspects of a kernel</p></li>
<li><p>::zeModuleGetNativeBinary - allows for a tool to retrieve the native binary of the application’s module, instrument it, then create a new module using the intrumented version</p></li>
<li><p><a class="reference internal" href="#api-tracing">API-Tracing</a> - same usage as Inter-Function Instrumentation above</p></li>
</ul>
<div class="section" id="compilation">
<h3>Compilation<a class="headerlink" href="#compilation" title="Permalink to this headline">¶</a></h3>
<p>A module must be compiled with foreknowledge that instrumentation will
be performed in order for the compiler to generate the proper profiling
meta-data. Therefore, when the instrumentation layer is enabled, a new
build flag is supported: “-zet-profile-flags”, where “” must be a
combination of ::zet_profile_flag_t, in hexidecimal.</p>
<p>As an example, a tool could use API Tracing to inject this build flag on
each ::zeModuleCreate call that the tool wishes to instrument. In
another example, a tool could recompile a Module using the build flag
and use API Tracing to replace the application’s Module handle with it’s
own.</p>
</div>
<div class="section" id="instrumentation">
<h3>Instrumentation<a class="headerlink" href="#instrumentation" title="Permalink to this headline">¶</a></h3>
<p>Once the module has been compiled with instrumentation enabled, a tool
may use ::zetModuleGetDebugInfo and ::zetKernelGetProfileInfo in order
to decode the application’s instructions and register usage for each
function in the module.</p>
<p>If a tool requires additional functions to be used, it may create other
module(s) and use ::zeModuleGetFunctionPointer to call functions between
the application and tool modules. A tool may use ::zeModuleGetFunctionPointer
to retrieve the Host and device address of each function in the module.</p>
<p>There are no APIs provided for the actual instrumentation. Instead this
is left up to the tool itself to decode the application module’s native
binary and inject native instructions. This model prevents the
instrumentation from being manipulated by the compiler.</p>
</div>
<div class="section" id="execution">
<h3>Execution<a class="headerlink" href="#execution" title="Permalink to this headline">¶</a></h3>
<p>If a tool requires changing the address of an application’s function,
then it should use API Tracing; for example, ::zeModuleGetFunctionPointer
and all flavors of ::zeCommandListAppendLaunchKernel.</p>
</div>
</div>
</div>
<div class="section" id="program-debug">
<h1>Program Debug<a class="headerlink" href="#program-debug" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction-3">
<span id="id5"></span><h2>Introduction<a class="headerlink" href="#introduction-3" title="Permalink to this headline">¶</a></h2>
<p>The program debug APIs provide tools a basic framework for inserting
breakpoints and accessing register values of device programs, as they
are executing on the device.</p>
<p>(more details coming soon…)</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="SYSMAN.html" class="btn btn-neutral float-right" title="Introduction" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../core/PROG.html" class="btn btn-neutral float-left" title="Core Programming Guide" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Intel

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>